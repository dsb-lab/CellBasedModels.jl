<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Fitting · CellBasedModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="CellBasedModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">CellBasedModels.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="Usage_intro.html">Introduction</a></li><li><a class="tocitem" href="Usage_Agent.html">Defining an ABM model</a></li><li><a class="tocitem" href="Usage_Community.html">Creating and evolving a Community</a></li><li class="is-active"><a class="tocitem" href="Usage_Fitting.html">Model Fitting</a><ul class="internal"><li><a class="tocitem" href="#Evaluation-function"><span>Evaluation function</span></a></li><li><a class="tocitem" href="#Search-space-gridSearch"><span>Search space - gridSearch</span></a></li><li><a class="tocitem" href="#Search-space-Swarm-Argorithm-and-others"><span>Search space - Swarm Argorithm and others</span></a></li><li><a class="tocitem" href="#Other-packages"><span>Other packages</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="Patterning.html">Patterning</a></li><li><a class="tocitem" href="Development.html">ICM Development</a></li><li><a class="tocitem" href="Aggregation.html">Particle aggregation</a></li><li><a class="tocitem" href="Bacteries.html">Bacterial Colony Growth</a></li><li><a class="tocitem" href="Chemotaxis.html">Bacterial chemotaxis</a></li></ul></li><li><a class="tocitem" href="Models.html">Models</a></li><li><a class="tocitem" href="API.html"><strong>API</strong></a></li><li><a class="tocitem" href="APIdevelopers.html">API for Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href="Usage_Fitting.html">Model Fitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Usage_Fitting.html">Model Fitting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dsb-lab/CellBasedModels.jl/blob/master/docs/src/Usage_Fitting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia">using CellBasedModels</code></pre><h1 id="Model-Fitting"><a class="docs-heading-anchor" href="#Model-Fitting">Model Fitting</a><a id="Model-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Fitting" title="Permalink"></a></h1><p>One of the aims of the agent based models is to describe experimental observations. However the models have a complex dependency of the parameters and in general not direct algorithms exist for their optimization.</p><p>In the package we provide the submodule <code>Fitting</code> that provides of some fitting methods for complex parameter landscapes:</p><table><tr><th style="text-align: center">Methods</th></tr><tr><td style="text-align: center"><code>gridSearch</code></td></tr><tr><td style="text-align: center"><code>swarmAlgorithm</code></td></tr><tr><td style="text-align: center"><code>beeColonyAlgorithm</code></td></tr><tr><td style="text-align: center"><code>geneticAlgorithm</code></td></tr></table><p>All methods require two basic arguments:</p><ul><li>An evaluation function. This is a function that has as input a set of parameters of the model in form of <code>DataFrameRow</code> and has to return a scalar value that indicates the goodness of the parameters. The usual steps in this function will be:<ul><li>Initialize a community with the provided parameters.</li><li>Evolution of the community</li><li>Evaluation of the goodness of fit.</li></ul></li><li>A search space. Dictionary specifying the parameters to be fitted and the region of space in which they have to be fitted.</li></ul><p>Let&#39;s see a very simple example. This example in fact would not need such complex fitting algorithms as we will optimize the parameter of an ODE, but it is sufficiently concise to get the idea.</p><p><strong>Example: Exponential decay</strong></p><p>Imagine that we want to make an optimization of a model such:</p>$<p>dx = -\delta x $</p><p>which analytic solution is:</p>$<p>x(t) = x_0 e^{-\delta t} $</p><p>and we want to find both <span>$x_0$</span> and <span>$\delta$</span>. Consider that the data comes from <span>$x_0=10$</span> and <span>$\delta = 1.$</span>.</p><pre><code class="language-julia">model = ABM(1,
    model = Dict(
        :δ=&gt;Float64
        ),
    agentODE = quote
        dt( x ) = -δ*x
    end,
);</code></pre><p>Moreover, we make a function of the exact. In other cases, this may be actual data from experiments.</p><pre><code class="language-julia">analyticSolution(t) = 10 .*exp.(-t);</code></pre><h2 id="Evaluation-function"><a class="docs-heading-anchor" href="#Evaluation-function">Evaluation function</a><a id="Evaluation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-function" title="Permalink"></a></h2><p>The evaluation function is a function that accepts a <code>DataFrameRow</code> which contains an instance of candidate parameters of the model.  The function is generic and internally you can declare a model, instantiate a community and evolve it as described in the previous steps. After the simulation has taken place, you evaluate how good is the fit to your observations. For that you define an error function to be <strong>minimized</strong>. The outcome of the error function is what the evaluation function will return.</p><p>For the example above a simulation function will look like:</p><pre><code class="language-julia">com = Community(model,dt=0.1)

function fitting(pars,community=com)
    #Initialize the model
    com = Community(model,
                x=pars.x0,
                δ=pars.δ,
                dt=0.1
            )
    setfield!(com,:abm,community.abm)
    #Evolve the model
    evolve!(com,steps=10)
    #Calulate error
    t = [i.t for i in com.pastTimes]
    d = getParameter(com,[:x])
    loos = sum( [abs( analyticSolution.(tt) .- x[1]) for (tt,x) in zip(t,d[:x])] )
    
    return loos
end;</code></pre><h2 id="Search-space-gridSearch"><a class="docs-heading-anchor" href="#Search-space-gridSearch">Search space - gridSearch</a><a id="Search-space-gridSearch-1"></a><a class="docs-heading-anchor-permalink" href="#Search-space-gridSearch" title="Permalink"></a></h2><p>The most basic algorithm will be to explore extensively a grid of parameter combinations and get the best one. For simple models with not many parameters, this method can be the fastest one.</p><p>For this method we have to provide vectors of potential candidates for each of the explored parameters.</p><pre><code class="language-julia">searchSpace = Dict(
    :x0 =&gt; Vector(.0:1:11),
    :δ =&gt; Vector(.1:.1:2) 
);</code></pre><p>Finally, we can explore the space of parameters to fit our model.</p><pre><code class="language-julia">CBMFitting.gridSearch(fitting, searchSpace)</code></pre> <div><div style = "float: left;"><span>DataFrameRow (3 columns)</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">x0</th><th style = "text-align: left;">δ</th><th style = "text-align: left;">_score_</th></tr><tr class = "subheader headerLastRow"><th class = "rowLabel" style = "font-weight: bold; text-align: right;"></th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowLabel" style = "font-weight: bold; text-align: right;">119</td><td style = "text-align: right;">10.0</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">1.48518</td></tr></tbody></table></div><h2 id="Search-space-Swarm-Argorithm-and-others"><a class="docs-heading-anchor" href="#Search-space-Swarm-Argorithm-and-others">Search space - Swarm Argorithm and others</a><a id="Search-space-Swarm-Argorithm-and-others-1"></a><a class="docs-heading-anchor-permalink" href="#Search-space-Swarm-Argorithm-and-others" title="Permalink"></a></h2><p>For more complex spaces that have many parameters, the grid search algorithm can be computationally impossible as the evaluations require to search all the combinations of all parameters.  For that, algorithms like the <code>swarmAlgorthms</code>, the <code>geneticAlgorithm</code> or the <code>beeAlgorthm</code> can be far more convenient.</p><p>For this algorithms, you can provide search spaces both in the terms of vectors of points for non-coninuous parameters as iin gridSearch or regions of exploration in the shape of tuples. </p><p>In our model, both parameters are continuous so we will define them as continous regions with tupples.</p><pre><code class="language-julia">searchSpace = Dict(
    :x0 =&gt; (.0,20),
    :δ =&gt; (.0,2) 
);</code></pre><pre><code class="language-julia">CBMFitting.swarmAlgorithm(fitting, searchSpace)</code></pre> <div><div style = "float: left;"><span>DataFrameRow (6 columns)</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowLabel" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">x0</th><th style = "text-align: left;">δ</th><th style = "text-align: left;">x0_velocity_</th><th style = "text-align: left;">δ_velocity_</th><th style = "text-align: left;">_score_</th><th style = "text-align: left;">_generation_</th></tr><tr class = "subheader headerLastRow"><th class = "rowLabel" style = "font-weight: bold; text-align: right;"></th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowLabel" style = "font-weight: bold; text-align: right;">967</td><td style = "text-align: right;">10.5734</td><td style = "text-align: right;">1.02219</td><td style = "text-align: right;">-0.109951</td><td style = "text-align: right;">-0.0193163</td><td style = "text-align: right;">1.51499</td><td style = "text-align: right;">10</td></tr></tbody></table></div><h2 id="Other-packages"><a class="docs-heading-anchor" href="#Other-packages">Other packages</a><a id="Other-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Other-packages" title="Permalink"></a></h2><p>Notime that the CellBasedModels can be also fitted using other packages as the really good <a href="https://docs.sciml.ai/Optimization/stable/">Optimization.jl</a>. The functions provided in CellBasedModels for fitting are just an self-contained alternative and most probable the more mature Optimizations.jl package will have better and more robust implementations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Usage_Community.html">« Creating and evolving a Community</a><a class="docs-footer-nextpage" href="Patterning.html">Patterning »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 7 March 2025 15:58">Friday 7 March 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
