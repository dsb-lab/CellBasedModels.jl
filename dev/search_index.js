var documenterSearchIndex = {"docs":
[{"location":"Development.html#Development","page":"ICM Development","title":"ICM Development","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The model from Saiz et al. has three parts in the model","category":"page"},{"location":"Development.html#Definition-of-the-model","page":"ICM Development","title":"Definition of the model","text":"","category":"section"},{"location":"Development.html#Mechanics","page":"ICM Development","title":"Mechanics","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The cells are spheroids that behave under the following equations:","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"m_ifracdv_idt =-bv_i+sum_j F_ij","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fracdx_idt =v_i","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"where the force is","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"F_ij=\nbegincases\nF_0(fracr_ijd_ij-1)(fracmu r_ijd_ij-1)frac(x_i-x_j)d_ijhspace1cmifd_ijmu r_ij\n0hspace5cmotherwise\nendcases","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"where d_ij is the Euclidean distance and r_ij is the sum of both radius.","category":"page"},{"location":"Development.html#Biochemical-interaction","page":"ICM Development","title":"Biochemical interaction","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"Each cell has a biochemical component that follows an equation of the form:","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fracdx_idt=fracα(1+x^n_i)^m(1+x^n_i)^m+(1+(langle xrangle_i)K)^2m-x_i","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"This is similar to the above case. The only detail required is to note that the average expression can be modeled as the combination of two interacting variables. The biochemical system is activated in the interval t_ont_off.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We made explicit that the average operator can be written as two interaction parameters that are the contraction along the second index that runs over the neighbours of each cell as,","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"N_ij=\nbegincases\n1hspace1cmdf_ranger_ij\n0hspace1cmotherwise\nendcases","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"X_ij=\nbegincases\nx_jhspace1cmdf_ranger_ij\n0hspace1cmotherwise\nendcases","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"langle xrangle_i=fracsum_j X_ijsum_j N_ij=fracX_iN_i","category":"page"},{"location":"Development.html#Growth","page":"ICM Development","title":"Growth","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The cells present division. The rules for the division in this model are. Random election of a division direction over the unit sphere. The daughter cells divide equally in mass and volume and are positioned in oposite directions around the division axis centered at the parent cell. The chemical concentration is divided asymmetrically with each cell taking 1pmsigma_x textUniform(01) for the parent cell. A new division time is assigned to each aghter cell from a uniform distribution textUniform(tau_div(1-sigma_div)tau_div(1+sigma_div)).","category":"page"},{"location":"Development.html#Creation-of-the-Agent","page":"ICM Development","title":"Creation of the Agent","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"#Package\nusing CellBasedModels\n#Functions for generating random distributions\nusing Random\nusing Distributions\n#Package for plotting in 3D\nusing GLMakie\nMakie.inline!(true)\n\nusing CSV\nusing DataFrames","category":"page"},{"location":"Development.html#Define-the-agent","page":"ICM Development","title":"Define the agent","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"First, we have to create an instance of an agent with all the propoerties of the agents.First, we have to create an instance of an agent with all the propoerties of the agents.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"model = ABM(3,\n\n    #Inherit model mechanics\n    baseModelInit = [CBMModels.softSpheres3D],\n\n    #Global parameters\n    model = Dict(\n        #Chemical constants\n        :α=>Float64, \n        :K=>Float64, \n        :nn=>Float64, \n        :mm=>Float64,\n        #Physical constants\n        :fRange=>Float64, \n        :mi=>Float64, \n        :ri=>Float64, \n        :k0=>Float64,\n        #Division constants\n        :fAdh=>Float64, \n        :τDiv=>Float64, \n        :σDiv=>Float64, \n        :c0=>Float64, \n        :σc=>Float64, \n        :nCirc=>Float64, \n        :σNCirc=>Float64,\n        :fMin=>Float64, \n        :fMax=>Float64, \n        :fPrE=>Float64, \n        :fEPI=>Float64, \n        :τCirc=>Float64, \n        :στCirc=>Float64, \n        :rESC=>Float64,\n        :nOn=>Float64, \n        :cMax=>Float64\n    ),\n    #Local float parameters\n    agent = Dict(\n        :c=>Float64,\n        :tDivision=>Float64, #Variable storing the time of division of the cell\n        :ci=>Float64, #Chemical activity of the neighbors\n        :ni=>Float64,  #Number of neighbors\n        :tOff=>Bool,    #indicate if the circuit for that cell is on or off (0,1)\n        :cellFate=>Int64 #Identity of the cell (1 DP, 2 EPI, 3 PRE)\n    ),\n    #Chemical dynamics\n    agentODE = quote\n\n        ni = 0\n        ci = 0\n        @loopOverNeighbors it2 begin\n            dij = CBMMetrics.euclidean(x,x[it2],y,y[it2],z,z[it2])\n            rij = r+r[it2]\n            if dij < fRange*rij\n                ni += 1\n                ci += c[it2]\n            end\n        end\n\n        if tOff == false && N > nOn #Activate circuit\n            dt( c ) = α*(1+c^nn)^mm/((1+c^nn)^mm+(1+(ci/ni)/K)^(2*mm)) - c\n        end\n\n    end,\n    #Interaction computation\n    agentRule=quote\n        #Circuit deactivation and commitment\n        if c < fPrE*cMax && tOff == false && N > nOn\n            cellFate = 3\n        elseif c > fEPI*cMax && tOff == false && N > nOn\n            cellFate = 2\n        end\n\n        if c < fMin*cMax && tOff == false && N > nOn\n            tOff = true\n        elseif c > fMax*cMax && tOff == false && N > nOn\n            tOff = true\n        end\n\n        #Growth\n        if t > tDivision\n            #Choose random direction in unit sphere\n            xₐ = CBMDistributions.normal(0,1); yₐ = CBMDistributions.normal(0,1); zₐ = CBMDistributions.normal(0,1)\n            Tₐ = sqrt(xₐ^2+yₐ^2+zₐ^2)\n            xₐ /= Tₐ;yₐ /= Tₐ;zₐ /= Tₐ    \n\n            #Chose a random distribution of the material\n            dist = CBMDistributions.uniform(1-σc,1+σc)\n\n            rsep = r/2\n            rnew = r/(2. ^(1. /3))\n            @addAgent( #Add new agent\n                x = x+rsep*xₐ,\n                y = y+rsep*yₐ,\n                z = z+rsep*zₐ,\n                vx = 0,\n                vy = 0,\n                vz = 0,\n                r = rnew,\n                m = m/2,\n                c = c*(dist),\n                tDivision = t + CBMDistributions.uniform(τDiv*(1-σDiv),τDiv*(1+σDiv))\n            )\n            @addAgent( #Add new agent\n                x = x-rsep*xₐ,\n                y = y-rsep*yₐ,\n                z = z-rsep*zₐ,\n                vx = 0,\n                vy = 0,\n                vz = 0,\n                r = rnew,\n                m = m/2,\n                c = c*(2-dist),\n                tDivision = t + CBMDistributions.uniform(τDiv*(1-σDiv),τDiv*(1+σDiv))\n            )\n            @removeAgent() # Remove agent that divided\n            \n        end\n    end,\n\n    agentAlg=CBMIntegrators.Heun()\n);","category":"page"},{"location":"Development.html#Community-construction-and-initialisation","page":"ICM Development","title":"Community construction and initialisation","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"Once with the model created, we have to construct an initial Community of agents to evolve.","category":"page"},{"location":"Development.html#Parameters","page":"ICM Development","title":"Parameters","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The model from the original version has some parameters defined. We create a dictionary with all the parameters from the model assigned.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"parameters = Dict([\n    :α => 10,\n    :K => .9,\n    :nn => 2,\n    :mm => 2,\n    :fRange => 1.2,\n    :mi => 10E-6,\n    :ri => 5,\n    :b => 10E-6,\n    :k0 => 10E-4,\n    :fAdh => 1.5,\n    :μ => 2,\n    :τDiv => 10,\n    :σDiv => .5,\n    :c0 => 3,\n    :σc => 0.01,\n    :nCirc => 20,\n    :σNCirc => .1,\n    :fMin => .05,\n    :fMax => .95,\n    :fPrE => .2,\n    :fEPI => .8,\n    :τCirc => 45.,\n    :στCirc => .02,\n    :rESC => 2,\n    :f0 => [1 1 1;1 1 1;1 1 1]\n]);","category":"page"},{"location":"Development.html#Initialise-the-community","page":"ICM Development","title":"Initialise the community","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The model starts from just one agent. Create the community and assign all the parameters to the Community object.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"function initializeEmbryo(parameters;dt)\n\n    com = Community(\n                model,\n                N=1,\n                dt=dt,\n                )\n\n    #Global parameters\n    for (par,val) in pairs(parameters)\n        com[par] = val\n    end\n\n    com.nOn = rand(Uniform(parameters[:nCirc]-parameters[:σNCirc],parameters[:nCirc]+parameters[:σNCirc]))\n    com.cMax = parameters[:α]/(1+1/(2*parameters[:K])^(2*parameters[:mm]))\n\n    #########Local parameters and variables###########\n    com.f0 = parameters[:k0].*parameters[:f0]# / parameters[:fAdh]\n    #Initialise locals\n    com.m = parameters[:mi]\n    com.r = parameters[:ri]\n    com.cellFate = 1 #Start neutral fate\n    com.tOff = false #Start with the tOff deactivated\n    #Initialise variables\n    com.x = 0.\n    com.y = 0.\n    com.z = 0.\n    com.vx = 0.\n    com.vy = 0.\n    com.vz = 0.\n    com.c = com.c0\n    com.tDivision = 1#rand(Uniform(com.τDiv-com.σDiv,com.τDiv+com.σDiv))\n\n    return com\n\nend;","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"com = initializeEmbryo(parameters,dt=0.001);","category":"page"},{"location":"Development.html#Creating-a-custom-evolve-step","page":"ICM Development","title":"Creating a custom evolve step","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"function customEvolve!(com,steps,saveEach)\n    loadToPlatform!(com,preallocateAgents = 100)\n    for i in 1:steps\n        agentStepDE!(com)\n        agentStepRule!(com)\n        update!(com)\n        computeNeighbors!(com)\n        if i % saveEach == 0\n            saveRAM!(com)\n        end\n        #Stop by time\n        if all(com.N .> 60)\n            break\n        end\n        #println(com.c[1:com.N])\n    end\n    bringFromPlatform!(com)\nend;","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"dt = 0.001\nsteps = round(Int64,50/dt)\nsaveEach = round(Int64,.5/dt)\n\ncom = initializeEmbryo(parameters,dt=dt);\ncustomEvolve!(com,steps,saveEach)","category":"page"},{"location":"Development.html#Visualization-of-results","page":"ICM Development","title":"Visualization of results","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We check how the agents starts to divide and choose a fate at late stages of the simulation.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"function getFates(com)\n    d = getParameter(com,[:t,:cellFate])\n\n    dict = Dict()\n    dict[\"t\"] = [i[1] for i in d[:t]]\n    dict[\"N\"] = [length(i) for i in d[:cellFate]]\n    for (fateNumber, fate) in zip([1,2,3],[\"DP\",\"EPI\",\"PRE\"])\n        dict[fate] = [sum(i.==fateNumber) for i in d[:cellFate]] \n    end\n\n    return dict\nend;","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"colorMap = Dict(\"DP\"=>Makie.wong_colors()[1],\"EPI\"=>Makie.wong_colors()[2],\"PRE\"=>Makie.wong_colors()[3])\ncolorMapNum = Dict(1=>Makie.wong_colors()[1],2=>Makie.wong_colors()[2],3=>Makie.wong_colors()[3]);","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure(resolution=(1500,300))\n\nd = getParameter(com,[:x,:y,:z,:r,:cellFate])\nfor (i,pos) in enumerate([1:round(Int64,length(com)/4):length(com);length(com)])\n    ax = Axis3(fig[1,i],aspect = :data)\n    color = [colorMapNum[i] for i in d[:cellFate][pos]]\n    meshscatter!(ax,d[:x][pos],d[:y][pos],d[:z][pos],markersize=d[:r][pos],color=color)\n    xlims!(ax,-5,5)\n    ylims!(ax,-5,5)\n    zlims!(ax,-5,5)\nend\n\ndisplay(fig)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure(resolution=(1500,600))\n\nax = Axis(fig[1,1],xlabel=\"Time\",ylabel=\"Proportions\",xlabelsize=40,ylabelsize=40)\nfates = getFates(com)\noffset = zeros(length(fates[\"N\"]))\nplots = []\nfor i in [\"DP\",\"EPI\",\"PRE\"]\n    prop = fates[i]./fates[\"N\"]\n    p = barplot!(ax,fates[\"t\"],prop,offset=offset,color=colorMap[i])\n    push!(plots,p)\n    offset .+= prop\nend\nLegend(fig[1,1], plots, [\"DP\",\"EPI\",\"PRE\"], halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=40)\n\ndisplay(fig)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html#Make-statistics-of-the-model","page":"ICM Development","title":"Make statistics of the model","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"This model contains stochasticity in the division times and the concentration of chemical components that the daughter agents receive. This will make different runs of the simulation to differ. In order to make statistics we run the model several times and collect information of the size and fates of the cells.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"function makeStatistics(comBase,parameters,dt,steps,saveEach,nRepetitions)\n\n    #Make simulations and add results to list\n    d = Dict(\"id\"=>Int64[],\"N\"=>Int64[],\"t\"=>Float64[],\"DP\"=>Int64[],\"EPI\"=>Int64[],\"PRE\"=>Int64[])\n    for i in 1:nRepetitions\n        #Make the simulations\n        com = initializeEmbryo(parameters,dt=dt);\n        setfield!(com,:abm,comBase.abm) #Avoid world problem assigning the functions of globally declared function model\n        customEvolve!(com,steps,saveEach)\n    \n        #Add them to the model\n        fates = getFates(com)\n        append!(d[\"id\"],i*ones(Int64,length(fates[\"N\"])))\n        append!(d[\"N\"],fates[\"N\"])\n        append!(d[\"t\"],fates[\"t\"])\n        append!(d[\"DP\"],fates[\"DP\"])\n        append!(d[\"EPI\"],fates[\"EPI\"])\n        append!(d[\"PRE\"],fates[\"PRE\"])\n    end\n\n    return d\nend;","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"dt = 0.001\nsteps = round(Int64,50/dt)\nsaveEach = round(Int64,1/dt)\nnRepetitions = 5\n\nprop = makeStatistics(com,parameters,dt,steps,saveEach,nRepetitions);","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure(resolution=(1000,800))\n\nax = Axis(fig[1,1],xlabel=\"N\",xlabelsize=40,ylabel=\"proportions\",ylabelsize=40)\nfor i in [\"DP\",\"EPI\",\"PRE\"]\n    boxplot!(ax,prop[\"N\"],prop[i]./prop[\"N\"],color=colorMap[i])\nend\nLegend(fig[1,1], plots, [\"DP\",\"EPI\",\"PRE\"], halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=40)\n\nax = Axis(fig[2,1],xlabel=\"t\",xlabelsize=40,ylabel=\"proportions\",ylabelsize=40)\nfor i in [\"DP\",\"EPI\",\"PRE\"]\n    boxplot!(ax,prop[\"t\"],prop[i]./prop[\"N\"],color=colorMap[i])\nend\nLegend(fig[2,1], plots, [\"DP\",\"EPI\",\"PRE\"], halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=40)\n\ndisplay(fig)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html#Fitting-the-model","page":"ICM Development","title":"Fitting the model","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The parameters above described were chosen to match the experimental observation. This was a qualitative fitting where the parameters where tuned by hand.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"In this section we will show how we can use tuning functions to choose optimize certain parameters of the model. In particular, we tune the model to fit parameters related with the chemical circuit to match the correct distributions of cells.","category":"page"},{"location":"Development.html#Upload-experimental-data","page":"ICM Development","title":"Upload experimental data","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We upload the experimental data that gives raise to this model.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"dataFull = CSV.read(\"data/development.csv\",DataFrame)\nfates = [\"DP\",\"EPI\",\"PRE\"];","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"data = Dict(\"N\"=>Float64[],[i=>Float64[] for i in [\"DP\",\"EPI\",\"PRE\"]]...)\nfor embryo in unique(dataFull[!,\"Embryo_ID\"])\n    embryoData = dataFull[dataFull[!,\"Embryo_ID\"] .== embryo,:]\n    push!(data[\"N\"], 0)\n    for celltype in fates\n        if celltype in embryoData[!,\"Identity.hc\"] && celltype in [\"DP\",\"EPI\",\"PRE\"]\n            val = embryoData[embryoData[!,\"Identity.hc\"].==celltype,\"count\"][1]\n            push!(data[celltype],val)\n            data[\"N\"][end] += val \n        elseif celltype in [\"DP\",\"EPI\",\"PRE\"]\n            push!(data[celltype],0)\n        end\n    end\nend","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure(resolution=(1000,500))\n\nax = Axis(fig[1,1],xlabel=\"N\",xlabelsize=30,ylabel=\"Cell fates\",ylabelsize=30)\n\noffset = zeros(size(data[\"DP\"])[1])\nlegend = []\norder = sortperm(data[\"N\"])\nfor cellId in fates\n    bp = barplot!(ax,data[cellId][order], offset=offset, color = colorMap[cellId])\n    push!(legend,bp)\n    offset .+= data[cellId][order]\nend\n\nfig","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We see that the data corresponds to sets ranging from 5 to 60 cells, being the usual sized between 5 to 30. ","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure(resolution=(1000,500))\nax = Axis(fig[1,1])\nlegend = []\n\ncluster = 1\nfor cellId in fates\n    Ngrouped = round.(Int64,data[\"N\"]/cluster).*cluster\n    l = boxplot!(ax,Ngrouped,(data[cellId]./data[\"N\"]),label=cellId, color=colorMap[cellId])\n    push!(legend,l)\nend\nLegend(fig[1,1], legend, fates, halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=40)\n\nfig","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html#Set-the-exploration-space","page":"ICM Development","title":"Set the exploration space","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The optimization algorithms require that you specify a set of parameters to optimize. in our case, our parameters correspond to parameters to the agent. However, they does not need to correcpond to parameters of the agent at all. They will be specified for the algorithm to sample from them and give new updates while optimising. ","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We have to define them as a dicctionary.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"explore = Dict([\n            :α=>(0,20),\n            :K=>(0,2),\n            :nn=>(0,5),\n            :mm=>(0,5),\n            :nCirc=>(0,30),\n            :σNCirc=>(0,20),\n            :c0=>(0,20)\n        ]);","category":"page"},{"location":"Development.html#Construct-loos-function","page":"ICM Development","title":"Construct loos function","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"With the data prepared to be compared, we set the loos function. ","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The loos function is a function that has to receive at least one argument, a RowDataframe object that contains the information of the parameters that are being fitted and has to return a value indicating how good wwere the simulations.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The function is very general so it can fit a many different routines.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"Our function basically contains the following steps:","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"Sets the new parameters\nRun several simulations for that set of parameters to get robust statistics\nCluster the results from the simulations as before to compare it to the experimental data\nCompare the experimental and simulation results using a Chi Square metric as loos value.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The specific form of the function will depend on the optimization algorithm at hand.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"function loosFunction(params;parameters=parameters,data=data,nRepetitions=1,saveEach=10,dt=0.001)\n\n    #Modify the set of parameters\n    parametersModified = copy(parameters)\n    parametersModified[:α] = params[:α][1]\n    parametersModified[:K] = params[:K][1]\n    parametersModified[:nn] = params[:nn][1]\n    parametersModified[:mm] = params[:mm][1]\n    parametersModified[:nCirc] = params[:nCirc][1]\n    parametersModified[:σNCirc] = params[:σNCirc][1]\n    parametersModified[:c0] = params[:c0][1]\n    \n    #Make a batch of simulations and get relevant information\n    prop = makeStatistics(com,parametersModified,dt,steps,saveEach,nRepetitions);\n\n    #Prepare data for fitting\n    p = transpose([prop[\"DP\"] prop[\"EPI\"] prop[\"PRE\"]]./prop[\"N\"])\n    \n    #Xi square loos\n    loos = 0.\n    for n in minimum(data[\"N\"]):maximum(data[\"N\"])\n        p = prop[\"N\"] .== n\n        if sum(p) > 0\n            dist = [mean(prop[\"DP\"][p])/n,mean(prop[\"EPI\"][p])/n,mean(prop[\"PRE\"][p])/n]\n            for (nn,dp,epi,pre) in zip(data[\"N\"],data[\"DP\"],data[\"EPI\"],data[\"PRE\"])\n                if nn == n\n                    loos += sum((dist.-[dp,epi,pre]./n).^2)\n                end\n            end\n        end\n    end\n    #Return loos\n    return loos\n    \nend","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"loosFunction (generic function with 1 method)","category":"page"},{"location":"Development.html#Check-stability-of-loos-function","page":"ICM Development","title":"Check stability of loos function","text":"","category":"section"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"We run the loos function several times to check that the results are consistent between runs. If the loos function returned different results outside the expected fluctuations, the model would not be proporly fitted as the algorithms would not be able to minimize consistently the cost.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"The fluctuations for the simulations using 10 repetitions of the simulation for the same parameters show already enough consistency.","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"initialisation = DataFrame([:α=>parameters[:α],:K=>parameters[:K],:nn=>parameters[:nn],:mm=>parameters[:mm],:nCirc=>parameters[:nCirc],:σNCirc=>parameters[:σNCirc],:c0=>parameters[:c0]])\n\nThreads.@threads for i in 1:3\n    println(loosFunction(initialisation,nRepetitions=1))\nend","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"43.66465425385882\n40.19961640416682\n39.79395560531394","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"#CBMFitting.swarmAlgorithm(loosFunction,explore,population=10,stopMaxGenerations=10,saveFileName=\"Optimization\",verbose=true)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"\u001b[32mGeneration 1/10 100%|████████████████████████████████████| Time: 0:06:33\u001b[39m\n\u001b[32mGeneration 2/10 100%|████████████████████████████████████| Time: 0:06:18\u001b[39m\n\u001b[32mGeneration 3/10 100%|████████████████████████████████████| Time: 0:06:29\u001b[39m\n\u001b[32mGeneration 4/10 100%|████████████████████████████████████| Time: 0:06:22\u001b[39m\n\u001b[32mGeneration 5/10 100%|████████████████████████████████████| Time: 0:06:28\u001b[39m\n\u001b[32mGeneration 6/10 100%|████████████████████████████████████| Time: 0:06:35\u001b[39m\n\u001b[32mGeneration 7/10 100%|████████████████████████████████████| Time: 0:06:20\u001b[39m\n\u001b[32mGeneration 8/10 100%|████████████████████████████████████| Time: 0:06:27\u001b[39m\n\u001b[32mGeneration 9/10 100%|████████████████████████████████████| Time: 0:06:41\u001b[39m\n\u001b[32mGeneration 10/10 100%|███████████████████████████████████| Time: 0:06:25\u001b[39m","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"<div><div style = \"float: left;\"><span>DataFrameRow (16 columns)</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">α</th><th style = \"text-align: left;\">nn</th><th style = \"text-align: left;\">K</th><th style = \"text-align: left;\">mm</th><th style = \"text-align: left;\">nCirc</th><th style = \"text-align: left;\">σNCirc</th><th style = \"text-align: left;\">c0</th><th style = \"text-align: left;\">αvelocity</th><th style = \"text-align: left;\">nnvelocity</th><th style = \"text-align: left;\">Kvelocity</th><th style = \"text-align: left;\">mmvelocity</th><th style = \"text-align: left;\">nCircvelocity</th><th style = \"text-align: left;\">σNCircvelocity</th><th style = \"text-align: left;\">c0velocity</th><th style = \"text-align: left;\">score</th><th style = \"text-align: left;\">generation</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Int64\" style = \"text-align: left;\">Int64</th></tr></thead><tbody><tr><td class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">93</td><td style = \"text-align: right;\">14.9389</td><td style = \"text-align: right;\">1.95144</td><td style = \"text-align: right;\">1.39619</td><td style = \"text-align: right;\">1.42773</td><td style = \"text-align: right;\">12.3225</td><td style = \"text-align: right;\">9.68273</td><td style = \"text-align: right;\">9.7174</td><td style = \"text-align: right;\">-0.0968626</td><td style = \"text-align: right;\">-0.0562549</td><td style = \"text-align: right;\">-0.0105383</td><td style = \"text-align: right;\">0.047756</td><td style = \"text-align: right;\">0.0882151</td><td style = \"text-align: right;\">0.278174</td><td style = \"text-align: right;\">0.0248736</td><td style = \"text-align: right;\">45.7751</td><td style = \"text-align: right;\">10</td></tr></tbody></table></div>","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"optimization = CSV.read(\"Optimization.csv\",DataFrame);","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"fig = Figure()\nax = Axis(fig[1,1],xticks=1:10,xlabel=\"Generations\",xlabelsize=30,ylabel=\"Log loos\",ylabelsize=30)\n\nscatter!(ax,optimization._generation_.+rand(Uniform(-.2,.2),length(optimization._generation_)),(optimization._score_))\n#xticks!(ax,[1,2,3],[1,2,3])\n\ndisplay(fig)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"propQualitative = makeStatistics(com,parameters,dt,steps,saveEach,nRepetitions);","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"params = optimization[argmin(optimization[!,\"_score_\"]),:]\nparametersModified = copy(parameters)\nparametersModified[:α] = params[:α][1]\nparametersModified[:K] = params[:K][1]\nparametersModified[:nn] = params[:nn][1]\nparametersModified[:mm] = params[:mm][1]\nparametersModified[:nCirc] = params[:nCirc][1]\nparametersModified[:σNCirc] = params[:σNCirc][1]\nparametersModified[:c0] = params[:c0][1]\n\npropFitted = makeStatistics(com,parametersModified,dt,steps,saveEach,10);","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"cluster = 4\ndt = 0.001\nsteps = round(Int64,50/dt)\nsaveEach = round(Int64,1/dt)\nnRepetitions = 5\n\nfig = Figure(resolution=(1500,300))\n\n#Real\nax = Axis(fig[1,1])\nlegend = []\nfor cellId in fates\n    Ngrouped = round.(Int64,data[\"N\"]/cluster).*cluster\n    l = boxplot!(ax,Ngrouped,(data[cellId]./data[\"N\"]),label=cellId, color=colorMap[cellId])\n    push!(legend,l)\nend\nxlims!(0,50)\nLegend(fig[1,1], legend, fates, halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=20)\n\n#Original fit\nax = Axis(fig[1,2],xlabel=\"N\",xlabelsize=40,ylabel=\"proportions\",ylabelsize=40)\nlegend = []\nfor i in [\"DP\",\"EPI\",\"PRE\"]\n    Ngrouped = round.(Int64,propQualitative[\"N\"]/cluster).*cluster\n    l = boxplot!(ax,Ngrouped,propQualitative[i]./propQualitative[\"N\"],color=colorMap[i])\n    push!(legend,l)\nend\nxlims!(0,50)\nLegend(fig[1,2], legend, [\"DP\",\"EPI\",\"PRE\"], halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=20)\n\n#Swarm fit\nax = Axis(fig[1,3],xlabel=\"N\",xlabelsize=40,ylabel=\"proportions\",ylabelsize=40)\nlegend = []\nfor i in [\"DP\",\"EPI\",\"PRE\"]\n    Ngrouped = round.(Int64,propFitted[\"N\"]/cluster).*cluster\n    l = boxplot!(ax,Ngrouped,propFitted[i]./propFitted[\"N\"],color=colorMap[i])\n    push!(legend,l)\nend\nxlims!(0,50)\nLegend(fig[1,3], legend, [\"DP\",\"EPI\",\"PRE\"], halign = :right, valign = :top, tellheight = false, tellwidth = false, labelsize=20)\n\ndisplay(fig)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"(Image: png)","category":"page"},{"location":"Development.html","page":"ICM Development","title":"ICM Development","text":"","category":"page"},{"location":"Chemotaxis.html#Chemotaxis","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"We use the model of bacterial cells by Volfson et al. (2008) and modify it to add active movement to the bacteries.","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"Over the physical model we add some active forces and a tumbling displacement model. The original physical model can be found in Models/rods.jl. We can copy its code and modify it in the following.","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"Add to the moving force an additional propulsion term.\nAdd to the agents a tumble and run protocol.\nAdd a medium which the model will detect.\nKeep cells inside some boundaries.","category":"page"},{"location":"Chemotaxis.html#Load-packages","page":"Bacterial chemotaxis","title":"Load packages","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"using CellBasedModels \nusing GLMakie\nMakie.inline!(true)\nusing GeometryBasics\nusing Distributions","category":"page"},{"location":"Chemotaxis.html#Modify-the-model","page":"Bacterial chemotaxis","title":"Modify the model","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"The model is a copy of the model as provided in Models/rods.jl. We mark the added lines to the code to adapt it to a chemotaxis model.","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"rods2DChemotaxis = ABM(2,\n    agent = Dict(\n            :vx=>Float64,\n            :vy=>Float64,\n            :theta=>Float64,\n            :ω=>Float64,\n            :d=>Float64,\n            :l=>Float64,\n            :m=>Float64,\n            :fx=>Float64,\n            :fy=>Float64,\n            :W=>Float64,\n            :pressure=>Float64,\n            :tTumble=>Float64, #We add to the agent a time to tumble or to run\n            :active=>Bool,     #Add a switch to change between tumbling and running\n        ),\n\n    model = Dict(\n            :kn=>Float64,\n            :γn=>Float64,\n            :γt=>Float64,\n            :μcc=>Float64,\n            :μcw=>Float64,\n            :β=>Float64,\n            :βω=>Float64,\n            :ωTumble=>Float64, #Add a torque of tumbling\n            :τTumble=>Float64, #Add a frequency of tumbling\n            :fChem=>Float64,   #Add a force of propulsion\n            :DMedium=>Float64, #Add a diffusion constant of the medium\n            :ωMedium=>Float64  #Add a frequency of the oscillating medium\n        ),\n\n    medium = Dict(\n        :mm => Float64        #Add a medium parameter\n    ),\n\n    agentODE = quote\n\n        fx = 0\n        fy = 0\n        W = 0\n        pressure = 0\n        @loopOverNeighbors i2 begin\n\n            Fijx, Fijy, Wij = CBMModels.rodForces(\n                                    x,y,d,l,theta,vx,vy,m,\n                                    x[i2],y[i2],d[i2],l[i2],theta[i2],vx[i2],vy[i2],m[i2],\n                                    kn,γn,γt,μcc,μcw\n                                )\n\n            #Append the interaction forces\n            fx += Fijx\n            fy += Fijy\n            #Append radial forces\n            W += Wij\n            #Keep track of preassure in the media\n            pressure += sqrt(Fijx^2+Fijy^2)\n            \n        end\n\n        #Equations\n        dt(x) =  vx \n        dt(y) =  vy \n        dt(vx) =  -β*vx+fx/m + active * fChem * cos(theta) #Add the propulsion force\n        dt(vy) =  -β*vy+fy/m + active * fChem * sin(theta) #Add the propulsion force\n        dt(theta) =  ω\n        dt(ω) =  W/(m*(d+l)^2/12+m*d^2)-βω*ω \n        \n    end,\n\n    agentRule = quote\n        #Code rule switch between tumbling and running\n        if tTumble < t && active #Activate tumbling if the particle was active (running) and the tumbling time ended\n            vx = 0\n            vy = 0\n            active = false\n            ω += ωTumble\n            tTumble += 1.\n        elseif tTumble < t && !active # Activate tumbling if the particle was tumbling (active off) and the running time ended (we resuse the tTumble time)\n            ω = 0\n            active = true\n            tTumble += CBMDistributions.exponential((2-mm)*τTumble)\n        end\n\n        # Very rudementary rule to to fix the bacteries to move inside the boundaries using onluy the center of the rod\n        if x < simBox[1,1]\n            x = simBox[1,1]\n        elseif x > simBox[1,2]\n            x = simBox[1,2]\n        end\n        if y < simBox[2,1]\n            y = simBox[2,1]\n        elseif y > simBox[2,2]\n            y = simBox[2,2]\n        end\n\n    end,\n\n    #Medium dynamics with dirichlet conditions and a wall that is as oscillating source of material\n    mediumODE=quote \n        if @mediumInside()\n            dt(mm) = DMedium*@∂2(1,mm)# we only diffuse in x as the symmetry is in x\n        elseif @mediumBorder(1,-1)\n            mm = 0\n        elseif @mediumBorder(1,1)\n            mm = sin(ωMedium*t)+1 #Oscillatory behaviour\n        elseif @mediumBorder(2,-1)\n            mm = 0\n        elseif @mediumBorder(2,-1)\n            mm = 0\n        end\n    end,\n\n    neighborsAlg=CBMNeighbors.CellLinked(cellEdge=4)\n);","category":"page"},{"location":"Chemotaxis.html#Initialising-the-community","page":"Bacterial chemotaxis","title":"Initialising the community","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"com = Community(\n    rods2DChemotaxis,\n    N=75,\n    dt=0.1,\n    simBox=[-20 20;-20 20.],\n    NMedium=[200,200],\n)\n\nm = 1/100\ng = 1/10000\nd = 1\ncom.kn = 2E6      * (m*g/d)\ncom.γn = 2.2E2    * sqrt(g/d)\ncom.γt = 2.2E2    * sqrt(g/d)\ncom.μcc = 0.1\ncom.μcw = 0.8\ncom.β = .8\ncom.βω = .8\ncom.fChem = 1\ncom.τTumble = 2\n# com.τTumbleMin = 1\ncom.ωTumble = 1\ncom.ωMedium = .01\ncom.DMedium = 3\n\ncom.m = 1.        \ncom.d = 1.        \ncom.l = 3;\ncom.x = rand(Uniform(com.simBox[1,:]...),com.N)\ncom.y = rand(Uniform(com.simBox[2,:]...),com.N)\ncom.theta = rand(Uniform(0,2π),com.N);","category":"page"},{"location":"Chemotaxis.html#Evolving-the-community","page":"Bacterial chemotaxis","title":"Evolving the community","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"As the evolution function may take some time, we add a progress message to the evolution to provide information of progress.","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"evolve!(com,steps=8000,saveEach=10,progressMessage=(com)->println(\"Step: \",round(Int,com.t)*10))","category":"page"},{"location":"Chemotaxis.html#Plot-of-the-results","page":"Bacterial chemotaxis","title":"Plot of the results","text":"","category":"section"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"We plot samples of the medium and bacteries.\nThe mean position of the bacteries over time.","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"fig = Figure(resolution=(1800,400))\n\nfor (j,i) in enumerate(1:round(Int,length(com)/4):length(com))\n    begin\n        d = getParameter(com,[:x,:y,:d,:l,:theta,:pressure,:mm])\n\n        ax = Axis(fig[1,2*j-1])\n\n        m = heatmap!(ax,\n                range(com.simBox[1,1],com.simBox[1,2],length=size(com.mm)[1]),\n                range(com.simBox[2,1],com.simBox[2,2],length=size(com.mm)[1]),\n                d[:mm][i],\n                colorrange=(0,2.)\n            )\n\n        xlims!(com.simBox[1,:]...)\n        ylims!(com.simBox[2,:]...)\n\n        x = Observable(d[:x][i])\n        y = Observable(d[:y][i])\n        xs1 = Observable(d[:x][i]+d[:l][i]./2 .*cos.(d[:theta][i]))\n        ys1 = Observable(d[:y][i]+d[:l][i]./2 .*sin.(d[:theta][i]))\n        xs2 = Observable(d[:x][i]-d[:l][i]./2 .*cos.(d[:theta][i]))\n        ys2 = Observable(d[:y][i]-d[:l][i]./2 .*sin.(d[:theta][i]))\n        ms = Observable([Point3f0(i/2,i/2,0) for i in d[:d][i]])\n        mc = Observable([Point3f0(ll,dd/2,dd/2) for (ll,dd) in zip(d[:l][i],d[:d][i])])\n        theta = Observable(d[:theta][i])\n\n        plotRods2D!(ax,x,y,xs1,ys1,xs2,ys2,ms,mc,theta,color=:red)\n\n        Colorbar(fig[1,2*j],m)\n    end\nend\n\ndisplay(fig)","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"(Image: png)","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"d = getParameter(com,[:x])\n\nfig = Figure(resolution=(400,400))\nax = Axis(fig[1,1],xlabel=\"time\",ylabel=\"medium\",\n            rightspinevisible=false,\n            topspinevisible=false,\n            xgridvisible=false,\n            ygridvisible=false\n        )\n\nlines!(ax,[i.t for i in com.pastTimes],[1-cos(com.ωMedium[1]*i.t) for i in com.pastTimes])\n\nax2 = Axis(fig[2,1],xlabel=\"time\",ylabel=\"mean(x)\",\n            rightspinevisible=false,\n            topspinevisible=false,\n            xgridvisible=false,\n            ygridvisible=false\n        )\nlines!(ax2,[i.t for i in com.pastTimes],[mean(i) for i in d[:x]])\n\ndisplay(fig)","category":"page"},{"location":"Chemotaxis.html","page":"Bacterial chemotaxis","title":"Bacterial chemotaxis","text":"(Image: png)","category":"page"},{"location":"Aggregation.html#Aggregation","page":"Particle aggregation","title":"Particle aggregation","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"In this model we are going to make a model with the following properties:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Soft spheres with repulsion and adeshion\nViscous brownian motion dynamics\nParticle confinement in a simulation space","category":"page"},{"location":"Aggregation.html#The-model","page":"Particle aggregation","title":"The model","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"The model will act with viscous brownian motion dynamics of the form:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"dx_i = underbracesum_j f(x_ix_j)_textdeterministic term dt + underbraceD_textstochastic term dW","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"where the forces of interaction are of the form","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"f(xy)=begincases\nF_rep(r_rep-x)hspace1cmtextif   x-y_2 = r_rep\n-F_atr(r_atr-x)hspace75cmtextif   r_rep  x-y_2  r_at\n0hspace245cmtextotherwise   \nendcases","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"and some radius of repulsion r_rep and attraction r_atr.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"The forces of the particles over the walls will be of the maximum size of repulsion f_rep.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"We are going to create the model step by step with the corresponding tests to check that it works properly.","category":"page"},{"location":"Aggregation.html#Load-the-package-and-the-plotting-functions","page":"Particle aggregation","title":"Load the package and the plotting functions","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"using CellBasedModels\nusing GLMakie\nMakie.inline!(true);","category":"page"},{"location":"Aggregation.html#Construct-the-AgentBasedModel-(ABM)","page":"Particle aggregation","title":"Construct the AgentBasedModel (ABM)","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"We are going to make the simulations of a model in 2D. By declaring a model with ABM(2,...) we are already declaring a model that includes two agent parameters: x and y. Agent parameters are parameters that have a value for each agent independently. ","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"If we want to have track of the forces exerted over each particle, we need to define additionally two more agent parameters:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"fx\nfy","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Additionally, our model has several global parameters. That is, parameters that are shared among all the agents in the system. Those are:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"rRep: radius of repulsion\nfrep: force of repulsion\nrAtr: radius of attraction\nfAtr: force of atraction\nD: diffusion coefficient","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"For defining the Stochastic Differential Equation, we will need to add two additional keyword arguments:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"agentODE: Where we define the deterministic part of the SDE\nagentSDE: Where we define the stochastic part of the SDE","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Let's create the model.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"model = ABM(2,\n\n    #In the keyword argument agent we declare all the agent arguments and its scope\n    agent = Dict(\n            :fx => Float64,\n            :fy => Float64,\n        ),\n\n    #In the keyword argument model we declare all the model arguments and its scope   \n    model = Dict(\n            :rRep => Float64,\n            :fRep => Float64,\n            :rAtr => Float64,\n            :fAtr => Float64,\n            :D => Float64\n        ),\n\n    # In here we define the ODE part\n    agentODE = quote\n\n        # Compute adhesion and repulsion forces\n            #Reset the parameters to zero zero\n        fx = 0\n        fy = 0\n            #Go over the neighbors and add the forces, for that we use the macro @loopOverNeighbors(iteratorSymbol,code) see more in documentation\n        @loopOverNeighbors i2 begin\n            d = CBMMetrics.euclidean(x,x[i2],y,y[i2])\n            dirx = (x-x[i2])/d\n            diry = (y-y[i2])/d\n            if d < rRep #Repulsion forces\n                fx += fRep*(rRep-d)*dirx  \n                fy += fRep*(rRep-d)*diry  \n            elseif d < rAtr #Attraction forces\n                fx += -fAtr*(rAtr-d)*dirx  \n                fy += -fAtr*(rAtr-d)*diry  \n            end\n        end\n            #Add the forces comming from the boundary interaction\n        if x < simBox[1,1]+rRep/2\n            fx += fRep\n        elseif x > simBox[1,2]-rRep/2\n            fx -= fRep        \n        end\n        if y < simBox[2,1]+rRep/2\n            fy += fRep\n        elseif y > simBox[2,2]-rRep/2\n            fy -= fRep\n        end\n\n        # Finally, define the deterministic term of the SDE\n        dt(x) = fx\n        dt(y) = fy\n    end,\n\n    # In here we define the SDE part\n    agentSDE = quote\n        # SDE term\n        dt(x) = D\n        dt(y) = D\n    end\n);","category":"page"},{"location":"Aggregation.html#Tests","page":"Particle aggregation","title":"Tests","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Now, we can test the correct definition of the properties. For that we are going to make two tests:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Test 1: Repulsion the agents\nTest 2: Resulsion from boundaries","category":"page"},{"location":"Aggregation.html#Test-repulsion-from-boundaries","page":"Particle aggregation","title":"Test repulsion from boundaries","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"For making this test we are going to create a simulation with two agents, put them close together and see how they separate from each other.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"For that we use the object Community(ABM, kwargs...) and we are going to define the following arguments:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"N: The number of agents of the model.\ndt: The integration step.\nsimBox: The simulation space. ","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Then, we will initialize the model and agent parameters.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"simBox = [-5. 5; -2 2]\n#Initialize community\ncom = Community(model,\n        N=2,\n        dt=.1,\n        simBox = simBox\n        );\n\n#Setup user paramaters\n        #Constants\ncom.rRep=.8\ncom.fRep=1\ncom.rAtr=1.\ncom.fAtr=1.\n        #Agent parameters\ncom.x=[-.1,.1]\ncom.y=[0.,0.];\n# If we do not define fx and fy, they are initialy set to zeros","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Now that everything is set, we can evolve the community with the function evolve! for some number of steps.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"evolve!(com,steps=50)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"And now, we visualize the results using Makie.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"For that, we extract from the community all the parameters that we want to plot for all times.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"d = getParameter(com,[:t,:x,:y,:fx,:fy])","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Dict{Symbol, Vector} with 5 entries:\n  :fy => [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0…\n  :y  => [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0…\n  :fx => [[-0.6, 0.6], [-0.6, 0.6], [-0.48, 0.48], [-0.36, 0.36], [-0.264, 0.26…\n  :t  => [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0  …  4.1, 4.2, 4.3, 4…\n  :x  => [[-0.1, 0.1], [-0.16, 0.16], [-0.22, 0.22], [-0.268, 0.268], [-0.304, …","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"And then we construct the plot.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"#Make the plot\nfig = Figure(resolution=(1100,550))\n\n#Plot the spheres at different times\nfor (j,i) in enumerate(1:5:20) #Step times\n    #Create axis\n    ax = Axis(fig[1,j],title=\"t = $(round(d[:t][i],digits=2))\")\n    #Add a simulation box rectangle in the background\n    mesh!(ax, [simBox[1,1] simBox[2,1];simBox[1,1] simBox[2,2];simBox[1,2] simBox[2,2];simBox[1,2] simBox[2,1]], [1 2 4; 2 3 4], color=:lightgrey)\n    #Add spheres with attraction radius    \n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rAtr][1]/2,color=(:blue,.3),transparency=true)\n    #Add spheres with attraction radius\n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rRep][1]/2,color=:red)\n    #Define the limits\n    xlims!(ax,-2,2)\n    ylims!(ax,-2,2)\nend\n\n#Plot position over time of one of the particles\nax = Axis(fig[2,1:2],title=\"distance\",xlabel=\"t\",ylabel=\"|x₁-x₂|\")\nlines!(d[:t],[abs(j-i) for (i,j) in d[:x]])\n\n#Plot forces over time of one of the particles\nax = Axis(fig[2,3:4],title=\"fx\",xlabel=\"t\",ylabel=\"|fx|\")\nlines!(d[:t],[abs(i) for (i,j) in d[:fx]])\n\n#Show the plots\ndisplay(fig)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"(Image: png)","category":"page"},{"location":"Aggregation.html#Test-repulsion-from-boundaries-2","page":"Particle aggregation","title":"Test repulsion from boundaries","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Now that we have shown the process, we do the same for the boundaries.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"simBox = [-2. 2; -2 2]\n#Initialize community\ncom = Community(model,\n        N=1,\n        dt=.1,\n        simBox = simBox,\n        );\n\n#Setup user paramaters\ncom.rRep=.8\ncom.fRep=1\ncom.rAtr=1.\ncom.fAtr=1.\ncom.x=[0]\ncom.y=[-2.5];","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"#Evolve\nevolve!(com,steps=15)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"#Get parameters\nd = getParameter(com,[:t,:x,:y,:fx,:fy])","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Dict{Symbol, Vector} with 5 entries:\n  :fy => [[1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0],…\n  :y  => [[-2.5], [-2.4], [-2.3], [-2.2], [-2.1], [-2.0], [-1.9], [-1.8], [-1.7…\n  :fx => [[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0],…\n  :t  => [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4,…\n  :x  => [[0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0], [0.0],…","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"#Plot\nfig = Figure(resolution=(1100,550))\n\n#Plot visually the results\nfor (j,i) in enumerate(1:4:13)\n    ax = Axis(fig[1,j],title=\"t = $(round(d[:t][i],digits=2))\")\n    mesh!(ax, [simBox[1,1] simBox[2,1];simBox[1,1] simBox[2,2];simBox[1,2] simBox[2,2];simBox[1,2] simBox[2,1]], [1 2 4; 2 3 4], color=:lightgrey)\n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rAtr][1]/2,color=(:blue,.3),transparency=true)\n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rRep][1]/2,color=:red)\n    xlims!(ax,-3,3)\n    ylims!(ax,-3,3)\nend\n\n#Plot position in i\nax = Axis(fig[2,1:2],title=\"distance\",xlabel=\"t\",ylabel=\"|x₁+2|\")\nlines!(d[:t],[i+2 for (i,) in d[:y]])\n\n#Plot forces in i\nax = Axis(fig[2,3:4],title=\"fx\",xlabel=\"t\",ylabel=\"|fx|\")\nlines!(d[:t],[abs(i) for (i,) in d[:fy]])\n\ndisplay(fig)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"(Image: png)","category":"page"},{"location":"Aggregation.html#Constructing-over-a-predefined-model","page":"Particle aggregation","title":"Constructing over a predefined model","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Now that we know that everything works for the model, we could start scaling it to many particles. But before we do that, we would like to add one more property to it as we would like to study the behavior of the particles as we cool down the movement. ","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"For that, we want to make a new model that have exactly the same behaviour as before but in addition we want that the model parameter D that controld the diffusion strength is lowered down slowly.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"We could rewrite all the model again from scratch, but in this case that is not necessary. We can define a new model that uses as a base the previous one and add the additional property.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Let's define the cooling down of the model with an exponential decay:","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"dD = -alpha_TDdt","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"model2 = ABM(2,\n\n    #Import the previous model\n    baseModelInit = [model],\n\n    #Add an additional model parameter that defines the speed of the diffusion parameter decay\n    model = Dict(\n        :αT => Float64\n    ),\n\n    #Add a ODE to describe the difussion\n    modelODE = quote\n        dt(D) = -αT*D\n    end,\n\n    agentAlg = CBMIntegrators.EM(),\n    modelAlg = DifferentialEquations.Euler(),\n    neighborsAlg = CBMNeighbors.CellLinked(cellEdge=2),\n);","category":"page"},{"location":"Aggregation.html#Evolve-the-model-an-check-the-behaviour","page":"Particle aggregation","title":"Evolve the model an check the behaviour","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"We can define now a now Commmunity and see the evolution in time. We can check that as the diffusion constant is reduced the particles start to aggregate as the adhesion forces dominate the behaviour over the active term.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"simBox = [-10. 10; -10 10]\nN = 100\ncom = Community(model2,\n        N=N,\n        dt=0.1,\n        simBox = simBox,\n        )\n\ncom.rRep=.8\ncom.fRep=1\ncom.rAtr=1.\ncom.fAtr=1.\ncom.αT=.001 \ncom.x = 20 .*rand(N) .-10\ncom.y = 20 .*rand(N) .-10\ncom.D=.15","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"0.15","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"evolve!(com,steps=8000,saveEach=1)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"d = getParameter(com,[:x,:y])\n\nfig = Figure(resolution=(1400,200))\n\nfor (pos,i) in enumerate(1:999:8000)\n    ax = Axis(fig[1,pos],title=\"D=$(round(com[i].D[1],digits=4))\")\n    mesh!(ax, [simBox[1,1] simBox[2,1];simBox[1,1] simBox[2,2];simBox[1,2] simBox[2,2];simBox[1,2] simBox[2,1]], [1 2 4; 2 3 4], color=:lightgrey)\n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rAtr][1]/2,color=(:blue,.0),transparency=true)\n    meshscatter!(ax,d[:x][i],d[:y][i],markersize=com[:rRep][1]/2,\n                color=[com[i].D[1] for i in 1:100],\n                colorrange=(0.,0.15),\n                colormap=:reds\n                )\n    xlims!(ax,(simBox[1,:].+[-1,1])...)\n    ylims!(ax,(simBox[2,:].+[-1,1])...)\n    # lines!(ax,[i[1] for i in d[:x]],[i[1] for i in d[:y]])\nend\n\n# save(\"agg.png\",fig)\n\ndisplay(fig)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"(Image: png)","category":"page"},{"location":"Aggregation.html#Neighbors-computational-dependence","page":"Particle aggregation","title":"Neighbors computational dependence","text":"","category":"section"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"It may be tempting to run simulations with a large number of particles. However, as we increase the number of particles, the computational time increases quadratically with the system size. ","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"This is due to the fact that the interaction forces in @loopOverNeighbors check all the forces over all neighbors. However, in this model only particles that are close together really interact. ","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"In CellBasedModels there are implementations of more efficient neighbors searching methods. You can provide them when creating the Community model.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"Check how alternative algorithms improve the speeding time.","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"modelFull = ABM(2, baseModelInit=[model2], agentAlg = CBMIntegrators.EM(), neighborsAlg=CBMNeighbors.Full())\nmodelVerlet = ABM(2, baseModelInit=[model2], agentAlg = CBMIntegrators.EM(), neighborsAlg=CBMNeighbors.VerletDisplacement(skin=2,nMaxNeighbors=20))\nmodelCellLinked = ABM(2, baseModelInit=[model2], agentAlg = CBMIntegrators.EM(), neighborsAlg=CBMNeighbors.CellLinked(cellEdge=2))\n\nfunction initialize(model,N,simBox)\n        return Community(model,N=N,\n                simBox = simBox,\n                \n                rRep=.8,\n                fRep=1,\n                rAtr=1.,\n                fAtr=1.,\n                D = .5,\n                x=rand(N).*(simBox[1,2]-simBox[1,1]).+simBox[1,1],\n                y=rand(N).*(simBox[2,2]-simBox[2,1]).+simBox[2,1],\n                dt=.1\n                );\nend;","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"ρ=.1\nS = 1\n\nN = []\ntFull = []\ntVerlet = []\ntCellLinked = []\nfor S in 1:.5:7\n    simBox = S.*[-10. 10; -10 10]\n    n = round(Int64,ρ*(simBox[1,2]-simBox[1,1])*(simBox[2,2]-simBox[2,1]))\n    push!(N,n)\n\n    com = initialize(modelFull,n,simBox); #Full (default) algorithm\n    evolve!(com,steps=10,saveEach=10,saveCurrentState=true)\n    t = @elapsed evolve!(com,steps=1000,saveEach=10,saveCurrentState=true)\n    push!(tFull,t)\n\n    com2 = initialize(modelVerlet,n,simBox); #Verlet list algorithm\n    evolve!(com2,steps=10,saveEach=10,saveCurrentState=true)\n    t = @elapsed evolve!(com2,steps=1000,saveEach=10,saveCurrentState=true)\n    push!(tVerlet,t)\n\n    com3 = initialize(modelCellLinked,n,simBox); #Cell linked algorithm\n    evolve!(com3,steps=10,saveEach=10,saveCurrentState=true)\n    t = @elapsed evolve!(com3,steps=1000,saveEach=10,saveCurrentState=true)\n    push!(tCellLinked,t)\nend","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"fig = Figure(resolution=(800,600))\nax = Axis(fig[1,1],xlabel=\"Number of agents\",ylabel=\"seconds\")\n\nl1 = scatter!(ax,Float64.(N),Float64.(tFull))\nl2 = scatter!(ax,Float64.(N),Float64.(tVerlet))\nl3 = scatter!(ax,Float64.(N),Float64.(tCellLinked))\nLegend(fig[1,2],[l1,l2,l3],[\"Full\",\"Verlet List\",\"Cell Linked\"])\n\ndisplay(fig)","category":"page"},{"location":"Aggregation.html","page":"Particle aggregation","title":"Particle aggregation","text":"(Image: png)","category":"page"},{"location":"Patterning.html#Patterning","page":"Patterning","title":"Patterning","text":"","category":"section"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"In this model we implement the paper from Corson et al. (2017).","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"using CellBasedModels\nusing GLMakie #Can be changes to CairoMakie\nusing Distributions\nMakie.inline!(true)","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"true","category":"page"},{"location":"Patterning.html#Create-model","page":"Patterning","title":"Create model","text":"","category":"section"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"First we define some functions that we will use for then model","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"fσ(x) = (1+tanh(2*x))/2\nfs0(x,t,l,S0,τg,L) = S0*fσ(1-t/τg)*(exp(-x^2/(2*L^2))+exp(-(1-x)^2/(2*L^2))) + fσ(t/τg-1)*(exp(-x^2/(2*l^2))+exp(-(1-x)^2/(2*l^2)))","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"fs0 (generic function with 1 method)","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"We create the ABM model.","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"model = ABM(2,\n\n    agent = Dict(\n        :s0 => Float64,\n        :u => Float64,\n        :s => Float64\n    ),\n    \n    model = Dict(\n        :a0=>Float64,\n        :a1=>Float64,\n        :τ=>Float64,\n        :l=>Float64,\n        :D=>Float64,\n        :S0=>Float64,\n        :τg=>Float64,\n        :L=>Float64\n    ),\n\n    agentODE = quote\n\n        s0 = fs0(x,t,l,S0,τg,L)\n        \n        s = 0\n        @loopOverNeighbors i2 begin\n            d = minimum(\n                        [\n                            (x-x[i2])^2+(y-y[i2])^2,\n                            (x-x[i2]+1)^2+(y-y[i2])^2,\n                            (x-x[i2]-1)^2+(y-y[i2])^2,\n                            (x-x[i2])^2+(y-y[i2]+1)^2,\n                            (x-x[i2])^2+(y-y[i2]-1)^2,\n                            (x-x[i2]+1)^2+(y-y[i2]+1)^2,\n                            (x-x[i2]+1)^2+(y-y[i2]-1)^2,\n                            (x-x[i2]-1)^2+(y-y[i2]+1)^2,\n                            (x-x[i2]-1)^2+(y-y[i2]-1)^2\n                        ]\n                    )\n            s += exp(-d/(2*l^2)) * u[i2]*(a0 + 3*u[i2]^3*a1/(1+u[i2]^2))\n        end\n\n        dt( u ) = fσ(2*(u-s-s0))/τ -u/τ\n\n    end,\n\n    agentSDE = quote\n        dt(u) = D\n    end,\n\n    agentAlg=DifferentialEquations.EM()\n);","category":"page"},{"location":"Patterning.html#Initialize-the-community","page":"Patterning","title":"Initialize the community","text":"","category":"section"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"Lx = 1\nLy = 1\nNx = 18\nNy = 9\n\ncom = Community(model,\n                N=2*Nx*Ny,\n                dt=0.001,\n                )\n\n#Global parameters\nλ = 5*10^-6; a0 = .05; a1 = 1 - a0; τ = 1/2; l = 0.085#1.75*λ; \nD = 5*10^-5; S0 = 2; τg = 1; L = .2; N = 324\ncom[:a0] = a0\ncom[:a1] = a1\ncom[:τ] = τ\ncom[:τg] = τg\ncom[:l] = l\ncom[:D] = D\ncom[:s0] = S0\ncom[:L] = L\n\n#Positions\ndist = Uniform(-1,1)\nposx = zeros(2*Nx*Ny); posy = zeros(2*Nx*Ny)\nfor i in 1:Nx\n    for j in 1:Ny\n        posx[Nx*(j-1)+i] = Lx*(i-0.5)/Nx +0.01*rand(dist)\n        posy[Nx*(j-1)+i] = Ly*(j-0.5)/Ny +0.01*rand(dist)\n    end\nend\nfor i in 1:Nx\n    for j in 1:Ny\n        posx[Nx*Ny+Nx*(j-1)+i] = Lx*(i)/Nx +0.01*rand(dist)\n        posy[Nx*Ny+Nx*(j-1)+i] = Ly*(j-0.5+cos(pi/3))/Ny +0.01*rand(dist)\n    end\nend\n\ncom[:x] = posx; com[:y] = posy;\n#Concentration\nu0 = [fs0(i,0.,l,S0,τg,L) for i in posx]\ncom[:u] = u0;\ncom[:s0] = u0;","category":"page"},{"location":"Patterning.html#Evolution","page":"Patterning","title":"Evolution","text":"","category":"section"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"evolve!(com,steps=4000,saveEach=10,saveCurrentState=true);","category":"page"},{"location":"Patterning.html#Plotting-results","page":"Patterning","title":"Plotting results","text":"","category":"section"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"comOut = getParameter(com,[:u])\n\nfig = Figure(resolution=(1500,300))\n\nfor (i,time) in enumerate(1:round(Int64,length(com)/4):length(com))\n    ax = Axis(fig[1,i])\n    meshscatter!(ax,com[:x],com[:y],markersize=3*10^-2,color=comOut[:u][time])\nend\n\ndisplay(fig)","category":"page"},{"location":"Patterning.html","page":"Patterning","title":"Patterning","text":"(Image: png)","category":"page"},{"location":"Models.html#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"Models.html","page":"Models","title":"Models","text":"Several models are already implemented in the CellBasedModels. You can use them by calling","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"CBMModels.NameOfModel","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"and introduced in the Agent using the baseModelInit or baseModelEnd keyord arguments. e.g.","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"ABM(2,\n    baseModelInit=[CBMModels.Bacteria2D]\n    #More arguments...\n)","category":"page"},{"location":"Models.html#Soft-spheres","page":"Models","title":"Soft spheres","text":"","category":"section"},{"location":"Models.html","page":"Models","title":"Models","text":"Model names\nCBMModel.softSpheres2D\nCBMModel.softSpheres3D","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"Parameter Scope Description\nb GlobalFloat Viscosity of the medium\nmu GLobalFloat Relative distance of cell-cell repulsion\nf0 LocalFloat Force of repulsion\nm LocalFloat Mass of the sphere\nr LocalFloat Radius of the sphere\nvx, vy, vz LocalFloat Velocity of sphere\nfx, fy, fz LocalFloatInteraction Force of repulsio interaction","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"The cells are spheroids that behave under the following equations:","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"m_ifracdv_idt =-bv_i+sum_j F_ij","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"fracdx_idt =v_i","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"where the force is","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"F_ij=\nbegincases\nf0(fracr_ijd_ij-1)(fracmu r_ijd_ij-1)frac(x_i-x_j)d_ijhspace1cmifd_ijmu r_ij\n0hspace5cmotherwise\nendcases","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"where d_ij is the Euclidean distance and r_ij is the sum of both radius.","category":"page"},{"location":"Models.html#Functions-assotiated-with-the-model","page":"Models","title":"Functions assotiated with the model","text":"","category":"section"},{"location":"Models.html#Rod-shape-agent","page":"Models","title":"Rod-shape agent","text":"","category":"section"},{"location":"Models.html","page":"Models","title":"Models","text":"Model names\nCBMModels.rod2D","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"Parameter Scope Description Normal values\nkn GlobalFloat Repulsion strength 0.0001\ngamma n GlobalFloat Normal velocity friction constant 1\ngamma t GlobalFloat Tangential velocity friction constant 1\nmu cc GlobalFloat Friction coefficient rod-rod .1\nbeta GlobalFloat Friction constant .5\nbetaomega GlobalFloat Angular friction constant .1\nvx, vy LocalFloat Velocity of rod \ntheta LocalFloat Angle of orientation of the rod \nomega LocalFloat Angular velocity of rod \nd LocalFloat Width of rod \nl LocalFloat Length of the rod \nm LocalFloat Mass of the rod \nfx, fy LocalFloatInteraction Repulsion force \nW LocalFloatInteraction Angular momentum ","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"Model of physical interactions for bacteria modeled as 2D rod-shape like cells. This implementation follows the model of Volfson et al.","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"<img src=\"./assets/Bacteria.png\" alt=\"drawing\" width=\"800\"/>","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"The forces that the rods feel are computed by the closest virtual spheres in contact. For a rod of mass m.","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"boldf_ij=f_nboldn_ij+f_tboldv_t","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"where boldn_ij if the normal vector between between the center of the spheres, defined as boldn_ij=(boldr_i-boldr_j)r_ij; and the normal and tangential forces are defined as","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"beginaligned\nf_n = k_ndelta^32-gamma_n fracm2delta v_n\nf_t = -min(gamma_tfracm2delta^12mu_ccf_n)\nendaligned","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"and delta=d-r_ij, v_n=boldv_ijboldn_ij and boldv_t=boldv_ij-v_nboldn_ij.","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"The equations of for a bacteria i are given by","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"beginaligned\nmddotboldr_i = sum_sboldf_s-beta m boldv\nboldIdotboldomega_i = sum_s(boldr_s-boldr_i)timesboldf_s - beta_omegaomega\nendaligned","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"where s denotes for the sum over the virtual interacting spheres acting on bacteria i and boldI is the tensor of inertia of a cylinder.","category":"page"},{"location":"Models.html#Functions-assotiated-with-the-model-2","page":"Models","title":"Functions assotiated with the model","text":"","category":"section"},{"location":"Models.html","page":"Models","title":"Models","text":"Here you may find functions that the defined model uses to compute it and can be used and modify it to make your own models.","category":"page"},{"location":"Models.html","page":"Models","title":"Models","text":"CBMModels.rodForces\nCBMMetrics.rodIntersection","category":"page"},{"location":"Models.html#CellBasedModels.CBMModels.rodForces","page":"Models","title":"CellBasedModels.CBMModels.rodForces","text":"function rodForces(\n    x,y,d,l,theta,vx,vy,m,\n    x2,y2,d2,l2,theta2,vx2,vy2,m2,\n    kn,γn,γt,μcc,μcw\n)\n\nFunction that return the forces in x and y and the torque force W for the rod model of Volfson et al..\n\nx: x position of the rod\ny: y position of the rod\nd: diameter of the rod\ntheta: angle of the rod in the plane\nvx: velocity of the rod in the x coordinates\nvy: velocity of the rod in the y coordinates\nm: mass of the rod\n\nThe same for all the parameters with 2 for the other interacting rod. Constants are defined in the paper and in the Models section of the documentation.\n\n\n\n\n\n","category":"function"},{"location":"Bacteries.html#Bacteries","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"In this example, we are going to create a bacterial model and grow a colony using it.","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"The implementation of the force interaction dynamics is the one presented by Volfson et al. (2008)\nWe use GPU accelerated dynamics","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"As described in other models, it is advised that the models are constructed by parts to avoid having to find bugs in a very complex system. Hence, we will split the model in two parts:","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"Forces model\nGrowth model","category":"page"},{"location":"Bacteries.html#Load-the-packages","page":"Bacterial Colony Growth","title":"Load the packages","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"using CellBasedModels\nusing CUDA\nusing Distributions\nusing GLMakie #Can be changes to Cairo or CLMakie\nusing GeometryBasics\nMakie.inline!(true);","category":"page"},{"location":"Bacteries.html#Forces-model","page":"Bacterial Colony Growth","title":"Forces model","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"We already use the defined forces model that is implemented in CBMModels. This is an exact copy of the rod model that you can find already predefined in Models/rods.jl. You can check the Models section of the documentation for more details.","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"rod2D = ABM(2,\n    agent = Dict(\n            :vx=>Float64,\n            :vy=>Float64,\n            :theta=>Float64,\n            :ω=>Float64,\n            :d=>Float64,\n            :l=>Float64,\n            :m=>Float64,\n            :fx=>Float64,\n            :fy=>Float64,\n            :W=>Float64,\n            :pressure=>Float64\n        ),    #Local Interaction Parameters\n\n    model = Dict(\n            :kn=>Float64,\n            :γn=>Float64,\n            :γt=>Float64,\n            :μcc=>Float64,\n            :μcw=>Float64,\n            :β=>Float64,\n            :βω=>Float64\n        ),        #Global parameters\n\n    agentODE = quote\n\n        fx = 0\n        fy = 0\n        W = 0\n        pressure = 0\n        @loopOverNeighbors i2 begin\n\n            #Use the model provided in the documentation\n            Fijx, Fijy, Wij = CBMModels.rodForces(\n                                    x,y,d,l,theta,vx,vy,m,\n                                    x[i2],y[i2],d[i2],l[i2],theta[i2],vx[i2],vy[i2],m[i2],\n                                    kn,γn,γt,μcc,μcw\n                                )\n\n            #Append the interaction forces\n            fx += Fijx\n            fy += Fijy\n            #Append radial forces\n            W += Wij\n            #Keep track of preassure in the media\n            pressure += sqrt(Fijx^2+Fijy^2)\n            \n        end\n\n        #Equations\n        dt(x) =  vx \n        dt(y) =  vy \n        dt(vx) =  -β*vx+fx/m \n        dt(vy) =  -β*vy+fy/m \n        dt(theta) =  ω \n        dt(ω) =  W/(m*(d+l)^2/12+m*d^2)-βω*ω \n        \n    end,\n\n    neighborsAlg=CBMNeighbors.CellLinked(cellEdge=4),\n    platform=GPU(),\n    agentAlg = CBMIntegrators.Heun()\n);\n","category":"page"},{"location":"Bacteries.html#Initialize-a-community-with-two-bacteries-and-check-forces","page":"Bacterial Colony Growth","title":"Initialize a community with two bacteries and check forces","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"com = Community(rod2D,\n            N=2,\n            dt=0.1,\n            simBox = [-20 20;-20 20.],\n            );\n\n#Natural units scales\nm = 1/100\ng = 1/10000\nd = 1\n#Model constants\ncom.kn = 2E6      * (m*g/d)\ncom.γn = 2.2E2    * sqrt(g/d)\ncom.γt = 2.2E2    * sqrt(g/d)\ncom.μcc = 0.1\ncom.μcw = 0.8\ncom.β = .8\ncom.βω = .8\n#Agent parameters\ncom.m = 1\ncom.d = 1\ncom.l = 3;\n    # You can play to put different positions and angles here and see the behaviour of the interacting bacteries\ncom.x = [0.,1]\ncom.y = [0.,1]\ncom.theta = [0,π/2];","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"evolve!(com,steps=50,saveEach=1,preallocateAgents=0)","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"function CBMPlots.plotRods2D!(ax, x, y, d, l, angle; kargs...)\n\n    Main.meshscatter!(ax,\n                x.+l./2 .*cos.(angle),\n                y.+l./2 .*sin.(angle),\n                marker=GeometryBasics.Sphere(Point3f0(0,0,0.),Float32(1)),\n                markersize=[\n                    Point3f0(i/2,i/2,0)\n                    for i in d\n                ];\n                kargs...\n            )\n\n    Main.meshscatter!(ax,\n                x.-l./2 .*cos.(angle),\n                y.-l./2 .*sin.(angle),\n                marker=GeometryBasics.Sphere(Point3f0(0,0,0),Float32(1)),\n                markersize=[\n                    Point3f0(i/2,i/2,0)\n                    for i in d\n                ];\n                kargs...\n            )\n            \n    Main.meshscatter!(ax,\n                x,\n                y,\n                marker=GeometryBasics.Cylinder(Point3f0(-.5,0,0),Point3f0(.5,0,0),Float32(1)),\n                markersize=[Point3f0(ll,dd/2,dd/2) for (ll,dd) in zip(l,d)],\n                rotations=angle;\n                kargs...\n            )\n\n    return\n\nend\n","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"fig = Figure(resolution=(1500,300))\n\nfor (i,j) in enumerate([1:round(Int,length(com)/4):length(com);length(com)])\n    ax = Axis3(fig[1,i],\n                azimuth=3*π/2,\n                elevation=π/2,\n                zlabelvisible=false,\n                zticklabelsvisible=false,\n                zgridvisible=false,\n                zspinesvisible=false\n            )\n\n    CBMPlots.plotRods2D!(ax,com[j][:x],com[j][:y],com[j][:d],com[j][:l],com[j][:theta],color=[:red,:blue])\n    xlims!(-5,5)\n    ylims!(-5,5)\nend\n\ndisplay(fig)","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"(Image: png)","category":"page"},{"location":"Bacteries.html#Growth-model","page":"Bacterial Colony Growth","title":"Growth model","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"We construct over the forces model to add bacterial growth and cell division rules.","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"rods2dGrowth = ABM(2,\n    baseModelInit = [rod2D],\n\n    agent = Dict(\n                :lTarget => Float64\n            ),\n\n    model = Dict(\n                :growth=>Float64,\n                :σlTarget=>Float64,\n                :lMax=>Float64,\n                :α=>Float64\n            ),\n\n    agentODE = quote\n        dt(l) = growth/(1+α*pressure) #linear growth with growth dependent on the pressure over the cell\n    end,\n\n    agentRule = quote #Bound cells\n        #Add division\n        if l > lTarget\n            ww = CBMDistributions.uniform(-.1,.1) #To add some random torque at division time\n            #Add a new cell\n            @addAgent(\n                    x=(l+d)/4*cos(theta)+x,\n                    y=(l+d)/4*sin(theta)+y,\n                    l=(l-d)/2,\n                    ω = ww,\n                    lTarget = CBMDistributions.uniform(lMax-σlTarget,lMax+σlTarget) #New target length at which the bactery should divide\n                    )\n            #Add a second cell\n            @addAgent(\n                    x=-(l+d)/4*cos(theta)+x,\n                    y=-(l+d)/4*sin(theta)+y,\n                    l=(l-d)/2,\n                    ω = -ww,\n                    lTarget = CBMDistributions.uniform(lMax-σlTarget,lMax+σlTarget) #New target length at which the bactery should divide\n                    )\n            #Remove the old cell\n            @removeAgent()\n        end\n    end,\n\n    neighborsAlg=CBMNeighbors.CellLinked(cellEdge=4),\n    platform=GPU(),\n    agentAlg=CBMIntegrators.Heun()\n);","category":"page"},{"location":"Bacteries.html#Grow-colony-from-one-cell","page":"Bacterial Colony Growth","title":"Grow colony from one cell","text":"","category":"section"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"com = Community(rods2dGrowth,\n            N=1,\n            dt=0.1,\n            simBox = [-100 100;-100 100.],\n            );\n\nm = 1/100\ng = 1/10000\nd = 1\ncom.kn = 2E6      * (m*g/d)\ncom.γn = 2.2E2    * sqrt(g/d)\ncom.γt = 2.2E2    * sqrt(g/d)\ncom.μcc = 0.1\ncom.μcw = 0.8\ncom.β = .8\ncom.βω = .8\ncom.growth = 1E-6 * (sqrt(g*d)) *100000\ncom.lMax = 3.     \ncom.σlTarget = .2 \ncom.α = 50\n\ncom.m = 1.        \ncom.d = 1.        \ncom.l = 2.99      \ncom.lTarget = 3.  \n\ncom.x = 0\ncom.y = 0\ncom.theta = 0;","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"evolve!(com,\n        steps=150000,saveEach=1000,\n        preallocateAgents=1000,\n        saveCurrentState=true,\n        progressMessage=(com)->if round(Int,com.t/com.dt)%10000 == 0; println(\"Step: \",round(Int,com.t/com.dt), \" N: \", com.N); end)","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"Step: 1000\nStep: 2000\nStep: 3000\nStep: 4000\nStep: 5000\nStep: 6000\nStep: 7000\nStep: 8000\nStep: 9000\nStep: 10000\nStep: 11000\nStep: 12000\nStep: 13000\nStep: 14000\nStep: 15000\nStep: 16000\nStep: 17000\nStep: 18000\nStep: 19000\nStep: 20000\nStep: 21000\nStep: 22000\nStep: 23000\nStep: 24000\nStep: 25000\nStep: 26000\nStep: 27000\nStep: 28000\nStep: 29000\nStep: 30000\nStep: 31000\nStep: 32000\nStep: 33000\nStep: 34000\nStep: 35000\nStep: 36000\nStep: 37000\nStep: 38000\nStep: 39000\nStep: 40000\nStep: 41000\nStep: 42000\nStep: 43000\nStep: 44000\nStep: 45000\nStep: 46000\nStep: 47000\nStep: 48000\nStep: 49000\nStep: 50000\nStep: 51000\nStep: 52000\nStep: 53000\nStep: 54000\nStep: 55000\nStep: 56000\nStep: 57000\nStep: 58000\nStep: 59000\nStep: 60000\nStep: 61000\nStep: 62000\nStep: 63000\nStep: 64000\nStep: 65000\nStep: 66000\nStep: 67000\nStep: 68000\nStep: 69000\nStep: 70000\nStep: 71000\nStep: 72000\nStep: 73000\nStep: 74000\nStep: 75000\nStep: 76000\nStep: 77000\nStep: 78000\nStep: 79000\nStep: 80000\nStep: 81000\nStep: 82000\nStep: 83000\nStep: 84000\nStep: 85000\nStep: 86000\nStep: 87000\nStep: 88000\nStep: 89000\nStep: 90000\nStep: 91000\nStep: 92000\nStep: 93000\nStep: 94000\nStep: 95000\nStep: 96000\nStep: 97000\nStep: 98000\nStep: 99000\nStep: 100000\nStep: 101000\nStep: 102000\nStep: 103000\nStep: 104000\nStep: 105000\nStep: 106000\nStep: 107000\nStep: 108000\nStep: 109000\nStep: 110000\nStep: 111000\nStep: 112000\nStep: 113000\nStep: 114000\nStep: 115000\nStep: 116000\nStep: 117000\nStep: 118000\nStep: 119000\nStep: 120000\nStep: 121000\nStep: 122000\nStep: 123000\nStep: 124000\nStep: 125000\nStep: 126000\nStep: 127000\nStep: 128000\nStep: 129000\nStep: 130000\nStep: 131000\nStep: 132000\nStep: 133000\nStep: 134000\nStep: 135000\nStep: 136000\nStep: 137000\nStep: 138000\nStep: 139000\nStep: 140000\nStep: 141000\nStep: 142000\nStep: 143000\nStep: 144000\nStep: 145000\nStep: 146000\nStep: 147000\nStep: 148000\nStep: 149000\nStep: 150000","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"fig = Figure(resolution=(1500,300))\n\nfor (i,j) in enumerate([1:round(Int,length(com)/4):length(com);length(com)])\n    ax = Axis3(fig[1,i],\n                azimuth=3*π/2,\n                elevation=π/2,\n                zlabelvisible=false,\n                zticklabelsvisible=false,\n                zgridvisible=false,\n                zspinesvisible=false\n            )\n\n    CBMPlots.plotRods2D!(ax,com[j][:x],com[j][:y],com[j][:d],com[j][:l],com[j][:theta],\n            color=com[j][:pressure], colorrange=(0,0.05))\n    xlims!(-20,20)\n    ylims!(-20,20)\nend\n\ndisplay(fig)","category":"page"},{"location":"Bacteries.html","page":"Bacterial Colony Growth","title":"Bacterial Colony Growth","text":"(Image: png)","category":"page"},{"location":"APIdevelopers.html#API-for-Developers","page":"API for Developers","title":"API for Developers","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"addEventGlobalAddAgent\nCurrentModule = CellBasedModels","category":"page"},{"location":"APIdevelopers.html#Base-Structures","page":"API for Developers","title":"Base Structures","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"BaseParameter\nUserParameter\nSavingFile","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.BaseParameter","page":"API for Developers","title":"CellBasedModels.BaseParameter","text":"struct BaseParameter\n\nObject containing the information of each field of the Community object that is fent to the different stepping functions as they appear in BASEPARAMETERS.\n\nField Description\ndtype::Symbol Type specifying between :Int and :Float dtype.\nshape::Tuple Shape of the field. The dimensions can be (:Local,:Global,:Neighbors (number of neighbors), :Dims (0,1,2,3), :Cells or :Medium).\nsaveLevel::Int Level specifying this variable at which level should be saved.\norigin::Symbol Origin of the parameter.\nreassign::Bool If to reupdate afte addign or removing agents of the Community.\nprotected::Bool If protected, you cannot access it directly with Community.parameter or Community[:parameter]\nreset::Bool If reset, this parameters will be set to zero before each interactionStep!.\nnecessaryFor::Vector{Symbol} When declaring Community, if necessary this parameters will be asked if not declared.\ninitialize Initialize function that creates the parameter if not specified explicitely during Community.\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#CellBasedModels.UserParameter","page":"API for Developers","title":"CellBasedModels.UserParameter","text":"mutable struct UserParameter\n\nStructure that contains the properties of each of the user declared parameters.\n\nField Description\ndtype::DataType Type of data\nscope::Symbol If :agent, :model or :medium parameter\nupdate::Bool If the variable is updated\nvariable::Bool Whether if this parameter is described with a Differential Equation\npos::Int Position that ocupies at the integration matrix\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#CellBasedModels.SavingFile","page":"API for Developers","title":"CellBasedModels.SavingFile","text":"mutable struct SavingFile\n\nStructure that stores the information of files used for saving Community information.\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#Auxiliar-Agent","page":"API for Developers","title":"Auxiliar - Agent","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"checkDeclared\nchange\nbaseParameterToModifiable\nbaseParameterNew\nagentArgs\nagentArgsNeighbors\ngetProperty\ngetSymbolsThat","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.checkDeclared","page":"API for Developers","title":"CellBasedModels.checkDeclared","text":"function checkDeclared(a::Symbol, abm::ABM) \nfunction checkDeclared(a::Array{Symbol}, abm::ABM)\n\nCheck if a symbol is already declared in the model or inherited models.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.change","page":"API for Developers","title":"CellBasedModels.change","text":"function change(x,code)\n\nFunction called by update to add the .new if it is an update expression (e.g. x += 4 -> x.new += 4).\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.baseParameterToModifiable","page":"API for Developers","title":"CellBasedModels.baseParameterToModifiable","text":"function baseParameterToModifiable(sym)\n\nReturn sym coming from UserParameter.basePar changed to modifiable. (e.g. liNM_ -> liM_)\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.baseParameterNew","page":"API for Developers","title":"CellBasedModels.baseParameterNew","text":"baseParameterNew(sym)\n\nReturn sym coming from UserParameter.basePar to new. (e.g. liM_ -> liMNew_)\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.agentArgs","page":"API for Developers","title":"CellBasedModels.agentArgs","text":"function agentArgs(abm;sym=nothing,l=3,params=BASEPARAMETERS)\n\nFunction that returns the arguments to be provided to a kernel function. If sym is provided, it will return them as sym.argument.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.agentArgsNeighbors","page":"API for Developers","title":"CellBasedModels.agentArgsNeighbors","text":"function agentArgs(sym=nothing;params=BASEPARAMETERS)\n\nFunction that returns the arguments obervable for the constructed functions. If symbol is given, it substitutes by the fielnames in form of by sym.fieldname.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.getProperty","page":"API for Developers","title":"CellBasedModels.getProperty","text":"function getProperty(dict::OrderedDict,property::Symbol)\n\nFor a Ordered dictionary of {Symbols, Structure} like BASEPARAMETERS, get a specific field of the structure.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.getSymbolsThat","page":"API for Developers","title":"CellBasedModels.getSymbolsThat","text":"function getSymbolsThat(dict::OrderedDict,property::Symbol,condition)\nfunction getSymbolsThat(dict::OrderedDict,property::Symbol,condition::Array)\n\nFor a Ordered dictionary of {Symbols, Structure} like BASEPARAMETERS, and a specific field (property) of the structure. If the property has as value of the condition, returns that symbol.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"Function generation","category":"page"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"functionDE\nfunctionRule","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.functionDE","page":"API for Developers","title":"CellBasedModels.functionDE","text":"function functionDE(abm,scope,type)\n\nCreates the final code for Differential Equation functions to be provided to DifferentialEquations.ODEProblem. scope is between agent, model and medium, type SDE or ODE.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.functionRule","page":"API for Developers","title":"CellBasedModels.functionRule","text":"function functionRule(abm,scope)\n\nCreates the final code provided to ABM in a Rule function and adds it to the ABM. scope is between agent, model and medium.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#Auxiliar-Metaprogramming","page":"API for Developers","title":"Auxiliar - Metaprogramming","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"makeSimpleLoop\naddCuda\ncudaAdapt\nvectorize\nclean","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.makeSimpleLoop","page":"API for Developers","title":"CellBasedModels.makeSimpleLoop","text":"function makeSimpleLoop(code,abm;nloops=nothing)\n\nWrap code in loop iterating over the Community agents in the correct platform and dimensions (for medium).\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.addCuda","page":"API for Developers","title":"CellBasedModels.addCuda","text":"function addCuda(code,platform::Symbol;oneThread=false)\nfunction addCuda(code,agent;oneThread=false)\n\nAdd cuda macro to execute the kernel with the correspondent number of threads and blocks. If one thread, launches the kernel just with one thread.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.cudaAdapt","page":"API for Developers","title":"CellBasedModels.cudaAdapt","text":"function cudaAdapt(code,platform)\n\nAdapt specific CPU forms of calling parameters (e.g. Atomic) to CUDA valid code (Atomic -> size 1 CuArray).\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.vectorize","page":"API for Developers","title":"CellBasedModels.vectorize","text":"function vectorize(code,agent)\n\nFunction that transforms the code provided in Agent to the vectorized form for wrapping around an executable function.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.clean","page":"API for Developers","title":"CellBasedModels.clean","text":"function clean(code,it=5)\n\nSimplify code by removing multiplications by 1 or 0 and additions of 0 that appear sometimes when generating the integration code.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#Auxiliar-Community","page":"API for Developers","title":"Auxiliar - Community","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"checkFormat\ncheckLoaded\n@kernelListSurvived!\n@kernelFillHolesParameters!\n@kernelUpdateParameters!\n@update!","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.checkFormat","page":"API for Developers","title":"CellBasedModels.checkFormat","text":"function checkFormat(sym,args,prop,dict,agent)\n\nFunction that checks that the args provided to Community are from the same type that the ones provided by automatic initialization property in BASEPARAMETERS.  If they are not, it gives an error.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.checkLoaded","page":"API for Developers","title":"CellBasedModels.checkLoaded","text":"function checkLoaded(com)\n\nFunction that give error if the Community has not been loaded. Called before any step function.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.@kernelListSurvived!","page":"API for Developers","title":"CellBasedModels.@kernelListSurvived!","text":"macro kernelListSurvived!()\n\nMacro that constructs the kernel that listes the survived agents from the end of the list to fill the left gaps by removed agents.\n\nGenerates the code of the kernel function:\n\nfunction kernelListSurvivedCPU!(community)\nfunction kernelListSurvivedGPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.@kernelFillHolesParameters!","page":"API for Developers","title":"CellBasedModels.@kernelFillHolesParameters!","text":"macro kernelFillHolesParameters!()\n\nMacro to generate the function to fill the holes left by dead agents with the survived agents listed by listSurvivedGPU! over all the parameters that have :Local dimension (are proportional to agents).\n\nCreates the function:\n\nkernelFillHolesBaseCPU!(community)\nkernelFillHolesBaseGPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.@kernelUpdateParameters!","page":"API for Developers","title":"CellBasedModels.@kernelUpdateParameters!","text":"macro kernelUpdateParameters!(platform)\n\nKernel to update agent parameters.\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.@update!","page":"API for Developers","title":"CellBasedModels.@update!","text":"macro updateGPU!(arg,arg2)\n\nMacro that constructs the function:\n\nfunction updateGPU!(community)\n\nFunction groups together the functions:\n\nlistSurvivedGPU!\nfillHolesGPU!\nupdateParametersGPU\n\nAnd updates the number of agents and resets the corresponding parmaeters after update.\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#Neighbors","page":"API for Developers","title":"Neighbors","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"CBMNeighbors.@verletNeighbors\nCBMNeighbors.@neighborsVerletTime\nCBMNeighbors.@verletDisplacement\nCBMNeighbors.@verletResetDisplacement\nCBMNeighbors.@neighborsVerletDisplacement\nCBMNeighbors.cellPos\nCBMNeighbors.cellPosNeigh\nCBMNeighbors.@assignCells\nCBMNeighbors.@sortAgentsInCells\nCBMNeighbors.@neighborsCellLinked\nCBMNeighbors.@verletNeighborsCLVD\nCBMNeighbors.@neighborsCLVD","category":"page"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@verletNeighbors","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@verletNeighbors","text":"macro verletNeighbors(platform, args...)\n\nMacro to generate the code for the computation of Verlet lists for different platforms and dimensions.\n\nAdds the following functions to the library:\n\nverletNeighbors!(x::Array)\nverletNeighbors!(x::Array,y::Array)\nverletNeighbors!(x::Array,y::Array,z::Array)\nverletNeighbors!(x::CuArray)\nverletNeighbors!(x::CuArray,y::CuArray)\nverletNeighbors!(x::CuArray,y::CuArray,z::CuArray)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@neighborsVerletTime","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@neighborsVerletTime","text":"macro neighborsVerletTime(platform, args...)\n\nMacro to generate the code for the computation of Verlet lists updated by Verlet Time algorithm.\n\nAdds the following functions to the library: \n\nneighborsVerletTime1CPU!(community)\nneighborsVerletTime2CPU!(community)\nneighborsVerletTime3CPU!(community)\nneighborsVerletTime1GPU!(community)\nneighborsVerletTime2GPU!(community)\nneighborsVerletTime3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@verletDisplacement","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@verletDisplacement","text":"macro verletDisplacement(platform, args...)\n\nMacro to generate the code for the check of Verlet lists recomputation flag according to Verlet Displacement algorithm.\n\nAdds the following functions to the library:\n\nverletDisplacementCPU!(x)\nverletDisplacementCPU!(x,y)\nverletDisplacementCPU!(x,y,z)\nverletDisplacementGPU!(x)\nverletDisplacementGPU!(x,y)\nverletDisplacementGPU!(x,y,z)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@verletResetDisplacement","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@verletResetDisplacement","text":"macro verletResetDisplacement(platform, args...)\n\nMacro to generate the code to store the positions of the agents in the last recomputation of Verlet lists for Verlet Displacement algorithm.\n\nAdds the following functions to the library:\n\nverletResetDisplacementCPU!(x)\nverletResetDisplacementCPU!(x,y)\nverletResetDisplacementCPU!(x,y,z)\nverletResetDisplacementGPU!(x)\nverletResetDisplacementGPU!(x,y)\nverletResetDisplacementGPU!(x,y,z)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@neighborsVerletDisplacement","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@neighborsVerletDisplacement","text":"macro neighborsVerletDisplacement(platform, args...)\n\nMacro to generate the code for the computation of Verlet lists updated by Verlet Displacement algorithm. This function puts together the action of:\n\nverletDisplacement\nresetVerletDisplacement\nverletList\n\nAdds the following functions to the library:\n\nneighborsVerletDisplacement1CPU!(community)\nneighborsVerletDisplacement2CPU!(community)\nneighborsVerletDisplacement3CPU!(community)\nneighborsVerletDisplacement1GPU!(community)\nneighborsVerletDisplacement2GPU!(community)\nneighborsVerletDisplacement3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.cellPos","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.cellPos","text":"cellPos(edge,x,xMin,xMax,nX)\ncellPos(edge,x,xMin,xMax,nX,y,yMin,yMax,nY)\ncellPos(edge,x,xMin,xMax,nX,y,yMin,yMax,nY,z,zMin,zMax,nZ)\n\nFunction that returns the position of the abm in a cell list given their coordinates and cell grid properties.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.cellPosNeigh","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.cellPosNeigh","text":"function cellPosNeigh(pos,i,nX)\nfunction cellPosNeigh(pos,i,nX,nY)\nfunction cellPosNeigh(pos,i,nX,nY,nZ)\n\nReturns the position of the neighbors cells to the current cell i (pos in 1D = 1-3, in 2D 1-9...) and gives -1 is the pos is a boundary.\n\ne.g.\n\ngrid = \n\n1  2  3  4 5  6  7  8 9 10 11 12\n\ncellPosNeigh(4,5,4,3) = -1 For i = 5 the outcomes of all the positions will be [-1,1,2,-1,5,6,-1,9,10]\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@assignCells","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@assignCells","text":"macro assignCells(platform, args...)\n\nMacro to generate the code to assign abm to a cell.\n\nAdds the following functions to the library:\n\nassignCells1CPU!(community)\nassignCells2CPU!(community)\nassignCells3CPU!(community)\nassignCells1GPU!(community)\nassignCells2GPU!(community)\nassignCells3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@sortAgentsInCells","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@sortAgentsInCells","text":"macro sortAgentsInCells(platform, args...)\n\nMacro to generate the code to sort agents in cells in cell order.\n\nAdds the following functions to the library:\n\nsortAgentsInCells1CPU!(community)\nsortAgentsInCells2CPU!(community)\nsortAgentsInCells3CPU!(community)\nsortAgentsInCells1GPU!(community)\nsortAgentsInCells2GPU!(community)\nsortAgentsInCells3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@neighborsCellLinked","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@neighborsCellLinked","text":"macro neighborsCellLinked(platform, args...)\n\nMacro to generate the code to compute neighbors according to cell linked algorithm. This function puts together the action of:     - assignCells     - sortAgentsInCells\n\nAdds the following functions to the library:\n\nneighborsCellLinked1CPU!(community)\nneighborsCellLinked2CPU!(community)\nneighborsCellLinked3CPU!(community)\nneighborsCellLinked1GPU!(community)\nneighborsCellLinked2GPU!(community)\nneighborsCellLinked3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@verletNeighborsCLVD","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@verletNeighborsCLVD","text":"macro verletNeighborsCLVD(platform, args...)\n\nMacro to generate the code for the computation of Verlet lists going over CellLinked lists for different platforms and dimensions .\n\nAdds the following functions to the library:\n\nverletNeighborsCLVDCPU!(x)\nverletNeighborsCLVDCPU!(x,y)\nverletNeighborsCLVDCPU!(x,y,z)\nverletNeighborsCLVDGPU!(x)\nverletNeighborsCLVDGPU!(x,y)\nverletNeighborsCLVDGPU!(x,y,z)\n\n\n\n\n\n","category":"macro"},{"location":"APIdevelopers.html#CellBasedModels.CBMNeighbors.@neighborsCLVD","page":"API for Developers","title":"CellBasedModels.CBMNeighbors.@neighborsCLVD","text":"macro neighborsCLVD(platform, args...)\n\nMacro to generate the code to compute neighbors according to CellLinked-VerletDistance algorithms.\n\nAdds the following functions to the library:\n\nneighborsCLVD1CPU!(community)\nneighborsCLVD2CPU!(community)\nneighborsCLVD3CPU!(community)\nneighborsCLVD1GPU!(community)\nneighborsCLVD2GPU!(community)\nneighborsCLVD3GPU!(community)\n\n\n\n\n\n","category":"macro"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CurrentModule = CellBasedModels","category":"page"},{"location":"API.html#Agent","page":"API","title":"Agent","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"ABM","category":"page"},{"location":"API.html#CellBasedModels.ABM","page":"API","title":"CellBasedModels.ABM","text":"mutable struct ABM\n\nBasic structure which contains the user defined parmeters of the model, the user rules of the agents, both in high level definition and the functions already compiled.\n\nElements\n\nField Description\ndims::Int Dimensions of the model.\nparameters::OrderedDict{Symbol,UserParameter} Dictionary of parameters of the model and its properties.\ndeclaredUpdates::Dict{Symbol,Expr} Dictionary of updating rules and their user defined content (high level code).\ndeclaredUpdatesCode::Dict{Symbol,Expr} Dictionary of updating rules after wrapping into code (low level code).\ndeclaredUpdatesFunction::Dict{Symbol,Function} Dictionary of updting rules and the compiled functions (compiled code).\nagentDEProblem ODEProblem or SDEProblem object of Agent\nagentAlg Algorithm for the ODEProblem or SDEProblem of Agent\nagentSolveArgs Parameters for the ODEProblem or SDEProblem of Agent\nmodelDEProblem ODEProblem or SDEProblem object of Model\nmodelAlg Algorithm for the ODEProblem or SDEProblem of Model\nmodelSolveArgs Parameters for the ODEProblem or SDEProblem of Model\nmediumDEProblem ODEProblem or SDEProblem object of Medium\nmediumAlg Algorithm for the ODEProblem or SDEProblem of Medium\nmediumSolveArgs Parameters for the ODEProblem or SDEProblem of Medium\nneighbors Algorithm to compute neighbors\nplatform Platform in which to run the model\nremovalOfAgents_::Bool Stores the information to check wether agents are removed in the code. Auxiliar parameter for generating the code.\n\nConstructors\n\nfunction ABM()\n\nGenerates an empty instance of ABM to be filled.\n\nfunction ABM(\n    dims;\n\n    agent=OrderedDict{Symbol,DataType}(),\n    agentRule::Expr=quote end,\n    agentODE::Expr=quote end,\n    agentSDE::Expr=quote end,\n\n    model=OrderedDict{Symbol,DataType}(),\n    modelRule::Expr=quote end,\n    modelODE::Expr=quote end,\n    modelSDE::Expr=quote end,\n\n    medium=OrderedDict{Symbol,DataType}(),\n    mediumRule::Expr=quote end,\n    mediumODE::Expr=quote end,\n    mediumSDE::Expr=quote end,\n\n    baseModelInit::Vector{ABM}=ABM[],\n    baseModelEnd::Vector{ABM}=ABM[],\n\n    agentAlg::Union{CustomIntegrator,DEAlgorithm} = CBMIntegrators.Euler(),\n    agentSolveArgs::Dict{Symbol,Any} = Dict{Symbol,Any}(),\n\n    modelAlg::Union{CustomIntegrator,DEAlgorithm} = CBMIntegrators.Euler(),\n    modelSolveArgs::Dict{Symbol,Any} = Dict{Symbol,Any}(),\n\n    mediumAlg::Union{CustomIntegrator,DEAlgorithm} = DifferentialEquations.AutoTsit5(DifferentialEquations.Rosenbrock23()),\n    mediumSolveArgs::Dict{Symbol,Any} = Dict{Symbol,Any}(),\n\n    neighborsAlg::Neighbors = CBMNeighbors.Full(),       \n    platform::Platform = CPU(),     \n)\n\nGenerates an agent based model with defined parameters and rules.\n\n Argument Description\nArgs dims Dimensions of the system.\nKwArgs agent=OrderedDict{Symbol,DataType}() Agent parameters\n agentRule::Expr=quote end Agent rules\n agentODE::Expr=quote end Agent Ordinary Differential Equations definition\n agentSDE::Expr=quote end Agent Stochastic Differential Equations term definition\n model=OrderedDict{Symbol,DataType}() Model parameters\n modelRule::Expr=quote end Model rules\n modelODE::Expr=quote end Model Ordinary Differential Equations definition\n modelSDE::Expr=quote end Model Ordinary Differential Equations definition\n medium=OrderedDict{Symbol,DataType}() Medium parameters\n mediumRule::Expr=quote end Medium rules\n mediumODE::Expr=quote end Medium Ordinary Differential Equations definition\n mediumSDE::Expr=quote end Medium Ordinary Differential Equations definition\n baseModelInit::Vector{ABM}=ABM[] ABM model whose rules will act before this ABM rules\n baseModelEnd::Vector{ABM}=ABM[] ABM model whose rules will act after this ABM rules\n\nFor a more extense explanation of how to define rules and parameters, read Usage in the documentation.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Macros","page":"API","title":"Macros","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"These are macros that can be used in the code.","category":"page"},{"location":"API.html","page":"API","title":"API","text":"AgentRule","category":"page"},{"location":"API.html","page":"API","title":"API","text":"@addAgent\n@removeAgent\n@loopOverNeighbors","category":"page"},{"location":"API.html#CellBasedModels.@addAgent","page":"API","title":"CellBasedModels.@addAgent","text":"macro addAgentCode(arguments)\n\nMacro that returns the special code based on the arguments provided to addAgent.\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.@removeAgent","page":"API","title":"CellBasedModels.@removeAgent","text":"macro removeAgent()\n\nMacro that returns the special code based on the arguments provided to removeAgent().\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.@loopOverNeighbors","page":"API","title":"CellBasedModels.@loopOverNeighbors","text":"macro loopOverNeighbors(code)\nmacro loopOverNeighbors(it1, code)\n\nMacro that creates the loop function to go over all neighbors of the agent. \n\nIt can be declared as\n\n@loopOverNeighbors for iterator in ___\n    #code\nend\n\nor\n\n@loopOverNeighbors iterator begin\n    #code\nend\n\nfor some iterator symbol. It can only be used in agent rules or DEs.\n\n\n\n\n\n","category":"macro"},{"location":"API.html","page":"API","title":"API","text":"Medium","category":"page"},{"location":"API.html","page":"API","title":"API","text":"@∂\n@∂2\n@mediumInside\n@mediumBorder","category":"page"},{"location":"API.html#CellBasedModels.@∂","page":"API","title":"CellBasedModels.@∂","text":"macro ∂(coord,code)\n\nDiscretizes the code term of a drift process. e.g. Agent in 2D\n\n∂(1,m) → (m[i1-1,i2]-m[i1-1,i2])/(2*dx)\n\nthe coordinate must be 1, 2 or 3, specifing the axis of differentiation.\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.@∂2","page":"API","title":"CellBasedModels.@∂2","text":"macro ∂2(coord,code)\n\nDiscretizes the code term of a drift process. e.g. Agent in 2D\n\n∂2(1,m) → (m[i1-1,i2]-2*m[i1,i2]+m[i1-1,i2])/dx^2\n\nthe coordinate must be 1, 2 or 3, specifing the axis of differentiation.\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.@mediumInside","page":"API","title":"CellBasedModels.@mediumInside","text":"macro mediumInside()\n\nMacro that returns true if mesh position is not in the border of the region.\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.@mediumBorder","page":"API","title":"CellBasedModels.@mediumBorder","text":"mediumBorder(coord, border)\n\nMacro that returns true if mesh position is in the lower (border=-1) or upper (border=1) border of the axis coordinate 1, 2 or 3.\n\n\n\n\n\n","category":"macro"},{"location":"API.html#Community","page":"API","title":"Community","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Community","category":"page"},{"location":"API.html#CellBasedModels.Community","page":"API","title":"CellBasedModels.Community","text":"Basic structure keeping the parameters of all the agents in the current simulation of a model.\n\nParameters to store information essential for Community simulation\n\nSymbol Description\nabm ABM model of the community\nuuid Unique identifier of the community\nloaded If loaded into the platform CPU or GPU\npastTimes::Array{Community} Store times when called to saveRAM!\nparameters::OrderedDict{Symbol,AbstractArray} Dictionary with the User Defined Parameters\nagentDEProblem ODEProblem or SDEProblem object of Agent\nmodelDEProblem ODEProblem or SDEProblem object of Model\nmediumDEProblem ODEProblem or SDEProblem object of Medium\n\nParameters seen in the kernels that may de used directly by the user\n\nSymbol Description\nt Time of the community\ndt Stepping time of the community\nN Number of agents\nNMedium Size of medium mesh\nsimBox Size of simulation box\ndx Size of the axis 1 in mesh medium\ndy Size of the axis 2 in mesh medium\ndz Size of the axis 3 in mesh medium\n\nParameters seen in the kernels that are for internal use\n\nSymbol Description\nid Identification of the agent\nnMax_ Maximum number of agents when loading to platform\nidMax_ Maximum id in the Community at all times\nNAdd_ Number of added agents in the present step\nNRemove_ Number of removed agents in the present step\nNSurvive_ Number of agents survived in this step\nflagSurvive_ 0 is agent survived this step, 1 if dead\nholeFromRemoveAt_ Holes left from agents that are dead\nrepositionAgentInPos_ List the positions of the agents that have to be reubicated to empty spaces\nflagRecomputeNeighbors_ 1 is neighbors have to be recomputed\n\nConstructors\n\nfunction Community()\n\nCreates fully empty community. Auxiliar method for the following method of declaration for the users.\n\nfunction Community(\n    abm::ABM; \n\n    dt::Union{Nothing,AbstractFloat} = nothing,\n    t::AbstractFloat = 0.,\n    N::Int = 1,\n    id::AbstractArray{Int} = 1:N,\n    NMedium::Union{Nothing,Vector{<:Int}} = nothing,\n    simBox::Union{Nothing,Matrix{<:Number}} = nothing,\n\n    args...\n)\n\nFunction to construct a Community that accepts to provide integration algorithms, neighboring algorithms, the computing platform and setting parameters of the community.\n\nFor a more specific indication of the usage see the UserGuide.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Platform-loading","page":"API","title":"Platform loading","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"loadToPlatform!\nbringFromPlatform!","category":"page"},{"location":"API.html#CellBasedModels.loadToPlatform!","page":"API","title":"CellBasedModels.loadToPlatform!","text":"function loadToPlatform!(com::Community;preallocateAgents::Int=0)\n\nFunction that converts the Community data into the appropiate format to be executed in the corresponding platform. It locks the possibility of accessing and manipulating the data by indexing and propety. If preallocateAgents is provided, it allocates that additional number of agents to the community.  Preallocating is necesssary as if more agents will be added during the evolution of the model (Going over the number of preallocated agents will run into an error.).\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.bringFromPlatform!","page":"API","title":"CellBasedModels.bringFromPlatform!","text":"function bringFromPlatform!(com::Community)\n\nReturn the Community object from the platform where it is being evolved.  It locks the possibility of accessing and manipulating the data by indexing and propety.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Evolution-functions","page":"API","title":"Evolution functions","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"evolve!\nstep!\nagentStepRule!\nagentStepDE!\nmodelStepRule!\nmodelStepDE!\nmediumStepRule!\nmediumStepDE!\nupdate!","category":"page"},{"location":"API.html#CellBasedModels.evolve!","page":"API","title":"CellBasedModels.evolve!","text":"function evolve!(community;\n    steps,saveEach=1,\n    saveToFile=false,fileName=nothing,overwrite=false,\n    saveCurrentState=false,\n    preallocateAgents=0,\n    progressMessage=(com)->nothing)\n\nPerforms step number of steps on the community, saving each saveEach number of steps the community instance using the saving function provided in saveFunction (See IO).  If saveCurrentState is true, the present instance is saved.\n\npreallocateAgents is an integer to sent to the loadToPlatform! function that allocates empty space for agents if the model has to grow. The maximum number of agents in the final simulation has to be specified in here.\n\nprogressMessage is a function that is executed every time we save an step and can be used to print some information of progress.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.step!","page":"API","title":"CellBasedModels.step!","text":"function step!(community)\n\nExecutes all the possible step functions and updates the parameters a single time.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.agentStepRule!","page":"API","title":"CellBasedModels.agentStepRule!","text":"function agentStepRule!(community)\n\nFunction that computes a local step of the community a time step dt.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.agentStepDE!","page":"API","title":"CellBasedModels.agentStepDE!","text":"function agentStepDE!(community)\n\nFunction that computes a integration step of the community a time step dt using the defined Integrator defined in Agent.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.modelStepRule!","page":"API","title":"CellBasedModels.modelStepRule!","text":"function agentStepRule!(community)\n\nFunction that computes a local step of the community a time step dt.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.modelStepDE!","page":"API","title":"CellBasedModels.modelStepDE!","text":"function modelStepDE!(community)\n\nFunction that computes a integration step of the community a time step dt using the defined Integrator defined in Agent.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.mediumStepRule!","page":"API","title":"CellBasedModels.mediumStepRule!","text":"function agentStepRule!(community)\n\nFunction that computes a local step of the community a time step dt.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.mediumStepDE!","page":"API","title":"CellBasedModels.mediumStepDE!","text":"function mediumStepDE!(community)\n\nFunction that computes a integration step of the community a time step dt using the defined Integrator defined in Agent.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.update!","page":"API","title":"CellBasedModels.update!","text":"function update!(community)\n\nFunction that updates all the parameters after making a step in the community.\n\n\n\n\n\n","category":"function"},{"location":"API.html#IO","page":"API","title":"IO","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"saveRAM!\nsaveJLD2\nloadJLD2","category":"page"},{"location":"API.html#CellBasedModels.saveRAM!","page":"API","title":"CellBasedModels.saveRAM!","text":"function saveRAM!(community::Community)\n\nFunction that stores the present configuration of community in the field Community.pastTimes.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.saveJLD2","page":"API","title":"CellBasedModels.saveJLD2","text":"saveJLD2(file::String, community::Community; overwrite=false)\n\nSave in file the current instance of the community. If some other community was being saved here, an error will raise. If overwrite=true is specified, it will remove the previous community.   \n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.loadJLD2","page":"API","title":"CellBasedModels.loadJLD2","text":"function loadJLD2(file::String)\n\nLoad the Community structure saved in file.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CBMMetrics.euclidean\nCBMMetrics.@euclidean\nCBMMetrics.manhattan\nCBMMetrics.@manhattan\nCBMMetrics.cellInMesh\nCBMMetrics.intersection2lines\nCBMMetrics.point2line\nCBMMetrics.pointInsideRod\nCBMMetrics.rodIntersection","category":"page"},{"location":"API.html#CellBasedModels.CBMMetrics.euclidean","page":"API","title":"CellBasedModels.CBMMetrics.euclidean","text":"euclidean(x1,x2)\neuclidean(x1,x2,y1,y2)\neuclidean(x1,x2,y1,y2,z1,z2)\n\nEuclidean distance metric between two positions.\n\nd = (x₁-x₂)²\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.@euclidean","page":"API","title":"CellBasedModels.CBMMetrics.@euclidean","text":"macro euclidean(it2)\nmacro euclidean(it1,it2)\n\nMacro that given the iterator symbos it1 and it2, give the corresponding euclidean distanve in the correct dimentions.  If it1 is not provided it asumes the default iteration index of agents (i1_).\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.CBMMetrics.manhattan","page":"API","title":"CellBasedModels.CBMMetrics.manhattan","text":"manhattan(x1,x2)\nmanhattan(x1,x2,y1,y2)\nmanhattan(x1,x2,y1,y2,z1,z2)\n\nManhattan distance metric between two positions.\n\nd = |x₁-x₂|\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.@manhattan","page":"API","title":"CellBasedModels.CBMMetrics.@manhattan","text":"macro manhattan(it2)\nmacro manhattan(it1,it2)\n\nMacro that given the iterator symbos it1 and it2, give the corresponding manhattan distanve in the correct dimentions.  If it1 is not provided it asumes the default iteration index of agents (i1_).\n\n\n\n\n\n","category":"macro"},{"location":"API.html#CellBasedModels.CBMMetrics.cellInMesh","page":"API","title":"CellBasedModels.CBMMetrics.cellInMesh","text":"function cellInMesh(edge,x,xMin,xMax,nX)\n\nGive the integer position in a regular discrete mesh with poits separamtions of edge, given a position in x. The simulation domain being (xMin, xMax) and maximum number of mesh points nX.\n\ne.g Grid with 6 points at [0,.1,.2,.3,.4,.5]\n\n>>> cellInMesh(.1,.29,0.,.5,6)\n4\n\nwhich if the closest point in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.intersection2lines","page":"API","title":"CellBasedModels.CBMMetrics.intersection2lines","text":"function intersection2lines(x1,y1,theta1,x2,y2,theta2,inf_eff=100000)\n\nFinds the point of intersection of two lines. You have to provide a point in space and and angle for eachline: (x1,y1,theta1) and (x2,y2,theta2).\n\nIf the lines are parallel, it returns a point effectively in the infinite. The effective distance is described by inf_eff`.\n\nReturns the point of intersection.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.point2line","page":"API","title":"CellBasedModels.CBMMetrics.point2line","text":"function point2line(x1,y1,x2,y2,theta2)\n\nGiven a point (x1,x2), finds the closest point projected over a line described by a point in the line and the angle: (x2,y2,theta2).\n\nReturns the coordinates of the closest point over the line.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.pointInsideRod","page":"API","title":"CellBasedModels.CBMMetrics.pointInsideRod","text":"function pointInsideRod(x1,y1,l1,theta1,pxAux,pyAux,separation)\n\nGiven a line segment described by it central point (x1,y1), its angle in the plate theta1 and its length l1; and given a point over the save line (pxAux,pyAux), returns the point if inside the segment or the closes extreme of the segment.  If provided a separation (0,1), it moves the point that separation.\n\nReturns the coordinates of the closest point over the segment.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMMetrics.rodIntersection","page":"API","title":"CellBasedModels.CBMMetrics.rodIntersection","text":"function rodIntersection(x1,y1,l1,theta1,x2,y2,l2,theta2;separation=0.99)\n\nGiven a two line segment described by it central point (x1,y2), its angle in the plate theta1 and its length l1; finds the closest spheres of both segments.\n\nReturns the coordinates of the closest spheres (x1Aux,y1Aux), (x2Aux,y2Aux).\n\n\n\n\n\n","category":"function"},{"location":"API.html#Random","page":"API","title":"Random","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Random number generators from distributions that are compatible both in CPU and GPU.","category":"page"},{"location":"API.html","page":"API","title":"API","text":"CBMDistributions.normal\nCBMDistributions.uniform\nCBMDistributions.exponential","category":"page"},{"location":"API.html#CellBasedModels.CBMDistributions.normal","page":"API","title":"CellBasedModels.CBMDistributions.normal","text":"normal(μ,σ)\n\nNormal distribution radom generation. μ mean, σ std.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMDistributions.uniform","page":"API","title":"CellBasedModels.CBMDistributions.uniform","text":"uniform(l0,l1)\n\nUniform distribution radom generation. l0 min, l1 max.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMDistributions.exponential","page":"API","title":"CellBasedModels.CBMDistributions.exponential","text":"exponential(θ)\n\nExponential distribution radom generation. θ mean.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Platform","page":"API","title":"Platform","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CPU\nGPU","category":"page"},{"location":"API.html#CellBasedModels.CPU","page":"API","title":"CellBasedModels.CPU","text":"\"     mutable struct CPU <: Platform\n\nCPU platform structure.\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.GPU","page":"API","title":"CellBasedModels.GPU","text":"\"     mutable struct GPU <: Platform\n\nCPU platform structure.\n\nThreads and blocks for each rule method\n\nagentThreads\nagentBlocks\nmodelThreads\nmodelBlocks\nmediumThreads\nmediumBlocks\n\n\n\n\n\n","category":"type"},{"location":"API.html#Integrators","page":"API","title":"Integrators","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Integrators can be used the ones from DifferentialEquations for ODE or SDE problems or the custom made solvers provided in ths package.","category":"page"},{"location":"API.html","page":"API","title":"API","text":"CBMIntegrators.Euler\nCBMIntegrators.Heun\nCBMIntegrators.RungeKutta4\nCBMIntegrators.EM\nCBMIntegrators.EulerHeun","category":"page"},{"location":"API.html#CellBasedModels.CBMIntegrators.Euler","page":"API","title":"CellBasedModels.CBMIntegrators.Euler","text":"mutable struct Euler <: CustomIntegrator\n\nEuler integrator for ODE problems.\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMIntegrators.Heun","page":"API","title":"CellBasedModels.CBMIntegrators.Heun","text":"mutable struct Heun <: CustomIntegrator\n\nHeun integrator for ODE problems.\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMIntegrators.RungeKutta4","page":"API","title":"CellBasedModels.CBMIntegrators.RungeKutta4","text":"mutable struct RungeKutta4 <: CustomIntegrator\n\nRungeKutta4 for ODE integrators\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMIntegrators.EM","page":"API","title":"CellBasedModels.CBMIntegrators.EM","text":"mutable struct EM <: CustomIntegrator\n\nEuler-Majurana integrator for SDE poblems.\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMIntegrators.EulerHeun","page":"API","title":"CellBasedModels.CBMIntegrators.EulerHeun","text":"mutable struct EulerHeun <: CustomIntegrator\n\nEuler-Heun method for SDE integration.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Neighbor-algorithms","page":"API","title":"Neighbor algorithms","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CBMNeighbors.Full\nCBMNeighbors.VerletTime\nCBMNeighbors.VerletDisplacement\nCBMNeighbors.CellLinked\nCBMNeighbors.CLVD","category":"page"},{"location":"API.html#CellBasedModels.CBMNeighbors.Full","page":"API","title":"CellBasedModels.CBMNeighbors.Full","text":"mutable struct Full <: Neighbors\n\nMethod that computes all against all neighbors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMNeighbors.VerletTime","page":"API","title":"CellBasedModels.CBMNeighbors.VerletTime","text":"mutable struct VerletTime <: Verlet <: Neighbors\n\nMethod that computes VerletList neighbors and updates it at fixed times.\n\nConstructor\n\nfunction VerletTime(;skin,dtNeighborRecompute,nMaxNeighbors)\n\n Parameter Description\nKwArgs skin is the maximum distance around center to check neighbors. \n dtNeighborRecompute is time step at which recompute Verlet Lists. \n nMaxNeighbors is the maximum number of neighbors that a cell may have. \n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMNeighbors.VerletDisplacement","page":"API","title":"CellBasedModels.CBMNeighbors.VerletDisplacement","text":"mutable struct VerletTime <: Verlet <: Neighbors\n\nMethod that computes VerletList neighbors and updates it whenever an agent moves too far from the initial position\n\nConstructor\n\nfunction VerletDisplacement(;skin,nMaxNeighbors)\n\n Parameter Description\nKwArgs skin is the maximum distance around center to check neighbors. \n nMaxNeighbors is the maximum number of neighbors that a cell may have. \n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMNeighbors.CellLinked","page":"API","title":"CellBasedModels.CBMNeighbors.CellLinked","text":"mutable struct CellLinked <: Neighbors\n\nMethod that computes Cell Linked neighbors and updates it whenever an agent moves too far from the initial position\n\nConstructor\n\nfunction CellLinked(;cellEdge)\n\n Parameter Description\nKwArgs cellEdge is the grid size to use to check for neighbors around neighbor cells. \n\n\n\n\n\n","category":"type"},{"location":"API.html#CellBasedModels.CBMNeighbors.CLVD","page":"API","title":"CellBasedModels.CBMNeighbors.CLVD","text":"mutable struct CLVD <: Verlet <: Neighbors\n\nMethod that computes Cell Linked and Verlet Displacement neighbors algorithms together to compute neighbors and only recompute when they left very far from center.\n\nConstructor\n\nfunction CLVD(;skin,nMaxNeighbors,cellEdge)\n\n Parameter Description\nKwArgs skin is the maximum distance around center to check neighbors. \n nMaxNeighbors is the maximum number of neighbors that a cell may have. \n cellEdge is the grid size to use to check for neighbors around neighbor cells. \n\n\n\n\n\n","category":"type"},{"location":"API.html#Fitting","page":"API","title":"Fitting","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CBMFitting.gridSearch\nCBMFitting.swarmAlgorithm\nCBMFitting.beeColonyAlgorithm\nCBMFitting.geneticAlgorithm","category":"page"},{"location":"API.html#CellBasedModels.CBMFitting.gridSearch","page":"API","title":"CellBasedModels.CBMFitting.gridSearch","text":"function gridSearch(evalFunction::Function,  \n    searchList::Dict{Symbol,<:Vector{<:Number}}; \n    returnAll::Bool=false,\n    saveFileName::Union{Nothing,String} = nothing,\n    args::Vector{<:Any} = Any[],\n    verbose=false)\n\nFunction that evaluates a grid of parameter configurations for a model.\n\n Parameter Description\nArgs evalFunction:: Function** : Function that takes a DataFrame with parameters, generates the simulations and returns a score of the fit. \n searchList::Dict{Symbol,<:Tuple{<:Number,<:Number}}}** : Dictionary of parameters and the ranges of exloration the parameters (e.g. :x => (0,1)). \nKwArgs returnAll::Bool = false** : If return the hole list of parameters explored or the just the most fit. \n saveFileName::Union{Nothing,String} = nothing** : If given a string, it saves the parameters explored in a file with the corresponding name. \n args::Vector{<:Any} = Any[]** : Additional arguments to give to evalFunction. \n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMFitting.swarmAlgorithm","page":"API","title":"CellBasedModels.CBMFitting.swarmAlgorithm","text":"function swarmAlgorithm(evalFunction::Function,  \n    searchList::Dict{Symbol,<:Union{<:Tuple{<:Number,<:Number},Vector{<:Number}}};\n    population::Int=100,\n    weightInertia::Number = .1,\n    weightGlobalBest::Number = .1, \n    weightPopulationBest::Number = .1, \n    stopMaxGenerations::Int = 10,\n    initialisation::Union{Nothing,DataFrame} = nothing,\n    returnAll::Bool = false,\n    saveFileName::Union{Nothing,String} = nothing,\n    args::Vector{<:Any} = Any[],\n    verbose=false)\n\nOptimization of the parameter space of a model that uses the Swarm Algorithm.\n\n Parameter Description\nArgs evalFunction:: Function Function that takes a DataFrame with parameters, generates the simulations and returns a score of the fit.\n searchList::Dict{Symbol,<:Tuple{<:Number,<:Number}}} Dictionary of parameters and the ranges of exloration the parameters (e.g. :x => (0,1)).\nKwArgs population::Int = 100 Size of the colony used at each generation for the optimization.\n weightInertia::Number = .1 Hyperparameter of the colony weighting the current velocity.\n weightGlobalBest::Number = .1 Hyperparameter of the colony weighting the global best solution.\n weightPopulationBest::Number = .1 Hyperparameter of the colony weighting the local best solution.\n stopMaxGenerations::Int = 10 How many generations do before stopping the algorithm.\n initialisation::Union{Nothing,DataFrame} = nothing DataFrame defining the initial parameters of the population. If nothing, they are set randomly.\n returnAll::Bool = false If return the hole list of parameters explored or the just the most fit.\n saveFileName::Union{Nothing,String} = nothing If given a string, it saves the parameters explored in a file with the corresponding name.\n args::Vector{<:Any} = Any[] Additional arguments to give to evalFunction.\n verbose=false If true, show progress bar during optimization.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMFitting.beeColonyAlgorithm","page":"API","title":"CellBasedModels.CBMFitting.beeColonyAlgorithm","text":"function beeColonyAlgorithm(\n    evalFunction::Function, \n    searchList::Dict{Symbol,<:Tuple{<:Number,<:Number}}; \n    population::Int=100,\n    limitCycles::Int = 10,\n    stopMaxGenerations::Int = 100,\n    returnAll::Bool = false,\n    initialisation::Union{Nothing,DataFrame} = nothing,\n    saveFileName::Union{Nothing,String} = nothing,\n    args::Vector{<:Any} = Any[],\n    verbose=false)\n\nOptimization of the parameter space of a model that uses the Bee Colony Algorithm.\n\n Parameter Description\nArgs evalFunction:: Function Function that takes a DataFrame with parameters, generates the simulations and returns a score of the fit.\n searchList::Dict{Symbol,<:Tuple{<:Number,<:Number}}} Dictionary of parameters and the ranges of exloration the parameters (e.g. :x => (0,1)).\nKwArgs population::Int=100 Size of the colony used at each generation for the optimization.\n limitCycles::Int = 10 Hyperparameter of the algorithm that says how many generations without update are waited until jump to other position.\n stopMaxGenerations::Int = 100 How many generations do before stopping the algorithm.\n returnAll::Bool = false If return the hole list of parameters explored or the just the most fit.\n initialisation::Union{Nothing,DataFrame} = nothing DataFrame defining the initial parameters of the population. If nothing, they are set randomly.\n saveFileName::Union{Nothing,String} = nothing If given a string, it saves the parameters explored in a file with the corresponding name.\n args::Vector{<:Any} = Any[] Additional arguments to give to evalFunction.\n verbose=false If true, show progress bar during optimization.\n\n\n\n\n\n","category":"function"},{"location":"API.html#CellBasedModels.CBMFitting.geneticAlgorithm","page":"API","title":"CellBasedModels.CBMFitting.geneticAlgorithm","text":"function geneticAlgorithm(\n    evalFunction::Function,  \n    searchList::Dict{Symbol,<:Union{<:Tuple{<:Number,<:Number},Vector{<:Number}}};\n    population::Int=100,\n    parentSelectionAlg::String = \"weighted\", #weighted or random\n    parentSelectionP::Number = .1, \n    mutationRate::Number = .1, \n    stopMaxGenerations::Int = 10,\n    initialisation::Union{Nothing,DataFrame} = nothing,\n    returnAll::Bool = false,\n    saveFileName::Union{Nothing,String} = nothing,\n    args::Vector{<:Any} = Any[],\n    verbose=false)\n\nOptimization of the parameter space of a model that uses the Particle Swarm Algorithm.\n\n Parameter Description\nArgs evalFunction:: Function Function that takes a DataFrame with parameters, generates the simulations and returns a score of the fit.\n searchList::Dict{Symbol,<:Tuple{<:Number,<:Number}}} Dictionary of parameters and the ranges of exloration the parameters (e.g. :x => (0,1)).\nKwArgs population::Int=100 Size of the colony used at each generation for the optimization.\n parentSelectionAlg::String = \"weighted\" Weigthing method of the population ot chose descendants.\n parentSelectionP::Number = .1 Hyperparameter of the algorithm indicating the proportion of parameters exchanged between parents.\n mutationRate::Number = .1 Hyperparameter of the algorithm indicating the probability of resampling the parameter with a uniform.\n stopMaxGenerations::Int = 10 How many generations do before stopping the algorithm.\n initialisation::Union{Nothing,DataFrame} = nothing DataFrame defining the initial parameters of the population. If nothing, they are set randomly.\n returnAll::Bool = false If return the hole list of parameters explored or the just the most fit.\n saveFileName::Union{Nothing,String} = nothing If given a string, it saves the parameters explored in a file with the corresponding name.\n args::Vector{<:Any} = Any[] Additional arguments to give to evalFunction.\n verbose=false If true, show progress bar during optimization.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"CBMPlots.plotRods2D!","category":"page"},{"location":"API.html#CellBasedModels.CBMPlots.plotRods2D!","page":"API","title":"CellBasedModels.CBMPlots.plotRods2D!","text":"function plotRods2D!(ax, x, y, d, l, angle; kargs...)\n\nPlot rod shape like cells using Makie functions.\n\n Parameter Description\nArgs ax Axis where to plot the rods\n x Coordinates of rods in x\n y Coordinates of rods in y\n d Diameter of the rod\n l Length of the rods\n angle Angle of the rods of rods in the XY plane\nKwArgs  All arguments that want to be passed to meshscatter! function as color etc...\n\nfunction plotRods2D!(ax, x, y, xs1, ys1, xs2, ys2, markerSphere, markerCylinder, angle; kargs...)\n\nPlot rod shape like cells using Makie functions. This method is useful to make videos of cells.\n\n Parameter Description\nArgs ax Axis where to plot the rods\n x Coordinates of center of rod in x\n y Coordinates of center of rod in y\n xs1 Coordinates of rod extreme in x\n ys1 Coordinates of rod extreme in y\n xs2 Coordinates of other rod extreme in x\n ys2 Coordinates of other rod extreme in y\n markerSphere Point3f0 describing the radius of the sphere in (x,y,z)\n markerCylinder Point3f0 describing the cylinder sizes in (l,rx,ry)\nKwArgs  All arguments that want to be passed to meshscatter! function as color etc...\n\n\n\n\n\n","category":"function"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"using CellBasedModels","category":"page"},{"location":"Usage_Fitting.html#Model-Fitting","page":"Model Fitting","title":"Model Fitting","text":"","category":"section"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"One of the aims of the agent based models is to describe experimental observations. However the models have a complex dependency of the parameters and in general not direct algorithms exist for their optimization.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"In the package we provide the submodule Fitting that provides of some fitting methods for complex parameter landscapes:","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Methods\ngridSearch\nswarmAlgorithm\nbeeColonyAlgorithm\ngeneticAlgorithm","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"All methods require two basic arguments:","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"An evaluation function. This is a function that has as input a set of parameters of the model in form of DataFrameRow and has to return a scalar value that indicates the goodness of the parameters. The usual steps in this function will be:\nInitialize a community with the provided parameters.\nEvolution of the community\nEvaluation of the goodness of fit.\nA search space. Dictionary specifying the parameters to be fitted and the region of space in which they have to be fitted.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Let's see a very simple example. This example in fact would not need such complex fitting algorithms as we will optimize the parameter of an ODE, but it is sufficiently concise to get the idea.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Example: Exponential decay","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Imagine that we want to make an optimization of a model such:","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"$","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"dx = -\\delta x $","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"which analytic solution is:","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"$","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"x(t) = x_0 e^{-\\delta t} $","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"and we want to find both x_0 and delta. Consider that the data comes from x_0=10 and delta = 1.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"model = ABM(1,\n    model = Dict(\n        :δ=>Float64\n        ),\n    agentODE = quote\n        dt( x ) = -δ*x\n    end,\n);","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Moreover, we make a function of the exact. In other cases, this may be actual data from experiments.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"analyticSolution(t) = 10 .*exp.(-t);","category":"page"},{"location":"Usage_Fitting.html#Evaluation-function","page":"Model Fitting","title":"Evaluation function","text":"","category":"section"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"The evaluation function is a function that accepts a DataFrameRow which contains an instance of candidate parameters of the model.  The function is generic and internally you can declare a model, instantiate a community and evolve it as described in the previous steps. After the simulation has taken place, you evaluate how good is the fit to your observations. For that you define an error function to be minimized. The outcome of the error function is what the evaluation function will return.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"For the example above a simulation function will look like:","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"com = Community(model,dt=0.1)\n\nfunction fitting(pars,community=com)\n    #Initialize the model\n    com = Community(model,\n                x=pars.x0,\n                δ=pars.δ,\n                dt=0.1\n            )\n    setfield!(com,:abm,community.abm)\n    #Evolve the model\n    evolve!(com,steps=10)\n    #Calulate error\n    t = [i.t for i in com.pastTimes]\n    d = getParameter(com,[:x])\n    loos = sum( [abs( analyticSolution.(tt) .- x[1]) for (tt,x) in zip(t,d[:x])] )\n    \n    return loos\nend;","category":"page"},{"location":"Usage_Fitting.html#Search-space-gridSearch","page":"Model Fitting","title":"Search space - gridSearch","text":"","category":"section"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"The most basic algorithm will be to explore extensively a grid of parameter combinations and get the best one. For simple models with not many parameters, this method can be the fastest one.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"For this method we have to provide vectors of potential candidates for each of the explored parameters.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"searchSpace = Dict(\n    :x0 => Vector(.0:1:11),\n    :δ => Vector(.1:.1:2) \n);","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Finally, we can explore the space of parameters to fit our model.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"CBMFitting.gridSearch(fitting, searchSpace)","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":" <div><div style = \"float: left;\"><span>DataFrameRow (3 columns)</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">x0</th><th style = \"text-align: left;\">δ</th><th style = \"text-align: left;\">_score_</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th></tr></thead><tbody><tr><td class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">119</td><td style = \"text-align: right;\">10.0</td><td style = \"text-align: right;\">1.0</td><td style = \"text-align: right;\">1.48518</td></tr></tbody></table></div>","category":"page"},{"location":"Usage_Fitting.html#Search-space-Swarm-Argorithm-and-others","page":"Model Fitting","title":"Search space - Swarm Argorithm and others","text":"","category":"section"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"For more complex spaces that have many parameters, the grid search algorithm can be computationally impossible as the evaluations require to search all the combinations of all parameters.  For that, algorithms like the swarmAlgorthms, the geneticAlgorithm or the beeAlgorthm can be far more convenient.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"For this algorithms, you can provide search spaces both in the terms of vectors of points for non-coninuous parameters as iin gridSearch or regions of exploration in the shape of tuples. ","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"In our model, both parameters are continuous so we will define them as continous regions with tupples.","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"searchSpace = Dict(\n    :x0 => (.0,20),\n    :δ => (.0,2) \n);","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"CBMFitting.swarmAlgorithm(fitting, searchSpace)","category":"page"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":" <div><div style = \"float: left;\"><span>DataFrameRow (6 columns)</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">x0</th><th style = \"text-align: left;\">δ</th><th style = \"text-align: left;\">x0_velocity_</th><th style = \"text-align: left;\">δ_velocity_</th><th style = \"text-align: left;\">_score_</th><th style = \"text-align: left;\">_generation_</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Int64\" style = \"text-align: left;\">Int64</th></tr></thead><tbody><tr><td class = \"rowLabel\" style = \"font-weight: bold; text-align: right;\">967</td><td style = \"text-align: right;\">10.5734</td><td style = \"text-align: right;\">1.02219</td><td style = \"text-align: right;\">-0.109951</td><td style = \"text-align: right;\">-0.0193163</td><td style = \"text-align: right;\">1.51499</td><td style = \"text-align: right;\">10</td></tr></tbody></table></div>","category":"page"},{"location":"Usage_Fitting.html#Other-packages","page":"Model Fitting","title":"Other packages","text":"","category":"section"},{"location":"Usage_Fitting.html","page":"Model Fitting","title":"Model Fitting","text":"Notime that the CellBasedModels can be also fitted using other packages as the really good Optimization.jl. The functions provided in CellBasedModels for fitting are just an self-contained alternative and most probable the more mature Optimizations.jl package will have better and more robust implementations.","category":"page"},{"location":"Usage_intro.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"The basic structure of an agent-based simulation model is:","category":"page"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"Definition of a model with its evolution rules.\nInitialization of a community of agents to be evolved.\nEvolution of agents during some iterations and storage of the simulation results.\nPosterior analysis of the results.","category":"page"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"We will cover the different parts of a CellBasedModels.jl from how to define models to optimization of the models.","category":"page"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"First, we will need to upload the package.","category":"page"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"using CellBasedModels","category":"page"},{"location":"Usage_intro.html#Basic-Structures-of-the-Package","page":"Introduction","title":"Basic Structures of the Package","text":"","category":"section"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"The package works around the two main structures:","category":"page"},{"location":"Usage_intro.html","page":"Introduction","title":"Introduction","text":"ABM: is the structure that contains all the information of the parameters and rules of the agents.\nCommunity: is the structure that containts a realization of a set of agents that have the parameters and evolution rules defined by an ABM. The Community structure will be initialized and then evolved using the rules defined in the ABM structure.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"using CellBasedModels","category":"page"},{"location":"Usage_Agent.html#Defining-an-ABM-model","page":"Defining an ABM model","title":"Defining an ABM model","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"The ABM structure contains all the information of a ABM Based model, their parameters and rules of evolution. There are four elements to take into account when defining agents:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Parameters. These can be splited in:\nUser-defined parameters: Parameters that are defined for the specific model that is being used.\nDefault parameters: Parameters that are defined for all models by default.\nUpdate rules. Rules that describe the behavior of the agents during the course of time.\nModel inheritance. More simple models over which we want to build more complex models.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Constructing an agent we use","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"ABM(dim,kwArgs...)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"where dim is the only required argument of the model and defined the dimensionality of the agent and can take values 0-3. The kwArgs are keyword arguments that define the parameters, rules and base models of the present model and that will be seing in detail in the following.","category":"page"},{"location":"Usage_Agent.html#Parameters","page":"Defining an ABM model","title":"Parameters","text":"","category":"section"},{"location":"Usage_Agent.html#Parameters-Default-Parameters","page":"Defining an ABM model","title":"Parameters - Default Parameters","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"By default, all agent models have a set of defined set of parameters. A list of the most relevant parameters for a user is:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Topic Symbol dtype Description\nTime t Float64 Absolute time of evolution of the community.\n dt Float64 Time increments in each step of the evolution.\nSize Community N Int64 The number of agents active in the community.\n NMedium Vector{Int64} Size of the grid in which the medium is being computed. This is necessary to be declared if medium parameters are declared by the user.\nId tracking id Int64 Unique identifier of the agent.\nSimulation space simBox Matrix{Float64} Simulation box in which cells are moving. This is necessary to define a region of space in which a medium will be simulated or for computing neighbors with CellLinked methods.\nPosition x Vector{Float64} Position of the agent in the x axis.\n y Vector{Float64} Position of the agent in the y axis.\n z Vector{Float64} Position of the agent in the z axis.\nPosition Medium x _m Array{Float64} Position of the medium gridpoints in the x axis. The shape will depend on the dimensionality o the model. This parameter is only present is a model with medium parameters is declared.\n y _m Array{Float64} Position of the medium gridpoints in the y axis. The shape will depend on the dimensionality o the model. This parameter is only present is a model with medium parameters is declared.\n z _m Array{Float64} Position of the medium gridpoints in the z axis. The shape will depend on the dimensionality o the model. This parameter is only present is a model with medium parameters is declared.\nGrid size Medium dx Float64 Grid separation of the medium in the x axis. This parameter is only present is a model with medium parameters is declared.\n dy Float64 Grid separation of the medium in the y axis. This parameter is only present is a model with medium parameters is declared.\n dz Float64 Grid separation of the medium in the z axis. This parameter is only present is a model with medium parameters is declared.\nGrid position Medium i1_ Int64 Index of the medium grid in the x coordinate.\n i2_ Int64 Index of the medium grid in the x coordinate.\n i3_ Int64 Index of the medium grid in the x coordinate.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"There are more parameters predefined in the model. The other parameters, however, are used internaly for the package to work properly and should in rare case used directly by the user. A complete list can be seen in the definition of the Community structure in API. You can identify them because they have a lower underscore in the end of their name.","category":"page"},{"location":"Usage_Agent.html#Parameters-User-defined-parmaeters","page":"Defining an ABM model","title":"Parameters - User defined parmaeters","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Apart from the default parameters, the user can define other parameters necessary for its model. ","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"The user parameters can have three scopes:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"model: Parameters that affect all the agents. These can be scalars or arrays of any shape.\nagent: Parameters have a different value for each agent. These will be stored as length N vectors. These can be scalars.\nmedium: Parameters that belong to the medium in which the model is embedded (if there is a medium defined for this model). These can be scalars only.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"For declaring the parameters, you will have to pass a dictionary-like object with keys as symbols of the parameters and datatypes as the stored values. Alternatively you can provide a structure and the ABM object will take the fields as the parameters.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"agent = ABM(3,                                  #Dimensions of the model\n                agent = Dict(                   # Agent parameters\n                    :a1=> Float64,\n                    :a2=> Int64\n                    ),\n                model = Dict(                   # Model parameters\n                    :g1=> Int64,\n                    :g2=> Array{Float64}\n                    ),\n                medium = Dict(                  # Medium parameters\n                    :m=>Float64\n                    )\n            )","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\ty (Float64 agent)\n\tz (Float64 agent)\n\txₘ (Float64 medium)\n\tyₘ (Float64 medium)\n\tzₘ (Float64 medium)\n\ta2 (Int64 agent)\n\ta1 (Float64 agent)\n\tg2 (Array{\n\n\n\n\n\nFloat64} model)\n\tg1 (Int64 model)\n\tm (Float64 medium)\n\n\nUPDATE RULES","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"WARNING: User default parameters name convention The is no rule to declare user-defined parameters but we advise that the names do not end with underscore (e.g. :a_).  This nomenclarute is in general used to name hidden parameters that are kept for internal use.","category":"page"},{"location":"Usage_Agent.html#Update-Rules","page":"Defining an ABM model","title":"Update Rules","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"After setting up the parameters of our agent, we can define the rules of evolution of our model and of recomputation.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"We can evolve all parameters in all the scopes with two methods:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Differential Equations: In the most general form we can define up to Stochastic Differential Equations. In these rules we will define the deterministic function f and stochastic functions g separately.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"d(x) = underbracef(xt)_ODEdt + underbraceg(xt)_SDEdW","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Rules: Rules that do not have any underlying differential equation to describe their evolution.","category":"page"},{"location":"Usage_Agent.html#Writting-update-rules","page":"Defining an ABM model","title":"Writting update rules","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Update rules in agents is almost normal julia code that you can write in a simplified level and then, when constructing the ABM structure, the code will be vectorized and adapted to be run in the corresponding platform.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"To provide a rule to the ABM, you will need to give the code to the kwArg in form of ","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"quote \n#code of update rule in here...\nend","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Let's see some examples to make it more clear.","category":"page"},{"location":"Usage_Agent.html#Rules","page":"Defining an ABM model","title":"Rules","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Example We want to create an agent that, at each step:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Makes a jump to left or right brought from a gaussian. \nIf the agent surpasses a certain limit in the left limit, is removed. \nAt random, with certain probability, it divides with a new parameter l.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"model = ABM(1, #Dimensions of the model\n    agent = Dict(\n        :l => Float64\n    ),\n    model = Dict(\n        :σ2 => Float64,    #Spread of the gaussian\n        :pDivision => Float64 #Global variable to set the probability at which it will divide\n    ),\n    agentRule = quote\n        x += CBMRandom.normal(0.,σ2) #We can call to distributions from Distributions.jl that are 1D\n        #We can make conditionals\n        if x__ > simBox[1,2] #We can use the default parameter simBox to define where is the left margin at which cells are removed. \n            @removeAgent()\n        elseif pDivision < Uniform(0,1) #We can make conditionals\n            @addAgent(\n                l = sin(CBMRandom.uniform(0,3*π))\n                ) #We add an agent that inherits x and initialize it with a new parameter l\n        end\n    end\n)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\tl (Float64 agent)\n\tpDivision (Float64 model)\n\tσ2 (Float64 model)\n\n\nUPDATE RULES\nagentRule\n begin\n    x__ += CBMRandom.normal(0.0, σ2)\n    if x__ > simBox[1, 2]\n        @removeAgent\n    elseif pDivision < Uniform(0, 1)\n        @addAgent l__ = sin(CBMRandom.uniform(0, 3π))\n    end\nend","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Several things to notice: ","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Parameters with double lower underline. If you notice, the update rule shows that when the modified parameters x and l, when reasiged with an updating operator, they where converted into x__ and l__, respectively. The underscore variables are the variables that store the modifications of the parameters before making the final step. This is performed this way to avoid modificating the parameters before all the modifications to all the agents, medium and model parameters are made. When calling the functions update! or evolve!, the new modifications will take place and will be incorporated into the original parameters. \nRandom numbers and GPU. To generate random numbers from distributions we can use the package Distributions.jl. This is perfectly fine if your code is going to run only on CPU. However, Distributions.jl is not compatible with GPU hence we provide the submodule CBMRandom with some random generators from different distributions that may run both in CPU and GPU.\nMacros. CellBasedModels provide several macros that are handy to perform some special functions of Agent Based Models. You can see the all the provided macros in API - Macros. In here we use the macro for adding agents to a model @addAgent and the one for removing agents @removeAgent.\nUse of Base parameters. For checking that the particle has left the simulation space, we use the base parameter simBox that defines the boundaries of the simulation.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Let's try now other example but now we want to modify a model parameter. For that, we will define a model rule.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Example Freeze the agents. Imagine that if certain time is met, we want to freeze all the agents that we described in local. One of the ways we can do it is by setting the jump to zero.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"model = ABM(1, #Dimensions of the model\n    agent = Dict(\n        :l => Float64\n    ),\n    model = Dict(\n        :σ2 => Float64,    #Spread of the gaussian\n        :pDivision => Float64, #Global variable to set the probability at which it will divide\n        :freeze => Bool\n    ),\n    agentRule = quote\n        x += freeze*Normal(0,σ2) \n        if x__ > simBox[1,2]\n            @removeAgent()\n        elseif pDivision < Uniform(0,1)\n            @addAgent(l = sin(Uniform(0,3*π)))\n        end\n    end,\n    modelRule = quote #Set freeze to false\n        if t < 10.\n            freeze = true\n        else\n            freeze = false\n        end\n    end\n)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\tl (Float64 agent)\n\tpDivision (Float64 model)\n\tσ2 (Float64 model)\n\tfreeze (\n\n\n\n\n\nBool model)\n\n\nUPDATE RULES\nmodelRule\n if t < 10.0\n    freeze__ = true\nelse\n    freeze__ = false\nend\n\nagentRule\n begin\n    x__ += freeze * Normal(0, σ2)\n    if x__ > simBox[1, 2]\n        @removeAgent\n    elseif pDivision < Uniform(0, 1)\n        @addAgent l__ = sin(Uniform(0, 3π))\n    end\nend","category":"page"},{"location":"Usage_Agent.html#Differential-Equations","page":"Defining an ABM model","title":"Differential Equations","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Parameters can be evolved also using Differential Equation. The way of defining the equations is very similar to that of DifferentialEquations.jl. CellBasedModels is currently compatible with ODE and SDE problems. The most general form of such problems is,","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"d(x) = underbracef(xt)_ODEdt + underbraceg(xt)_SDEdW","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Where the functions f and g define the deterministic and stochastic terms, in general. Let's see an example to learn how to define models with these equations.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Example The Ornstein–Uhlenbeck process is described by a function of the form:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"d(x) = -xdt + DdW","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"We want a model that:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Evolves under a 2D OU process\nKeeps track of the number of neighboring cells in a radius","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"model = ABM(2,\n    model = Dict(\n        :dist => Float64, #Maximum distance to compute neighbor distance\n        :D => Float64\n        ),\n    agent = Dict(\n        :nNeighs=> Int64  #Number of neighbors that the agent has\n        ),\n    agentRule = quote\n        nNeighs = 0 #Set it to zero before starting the computation\n        @loopOverNeighbors it2 begin\n            d = CBMMetrics.euclidean(x,x[it2],y,y[it2]) #Using euclidean matric provided in package\n            if d < dist\n                nNeighs += 1 #Add 1 to neighbors\n            end\n        end\n    end,\n    agentODE = quote #Here we put the deterministic term\n        dt(x) = -x\n        dt(y) = -y\n    end,\n    agentSDE = quote #Here we put the stochastic term\n        dt(x) = D\n        dt(y) = D\n    end,\n\n    platform = CPU(),\n    neighborsAlg = CBMNeighbors.CellLinked(cellEdge=1)\n)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\ty (Float64 agent)\n\tnNeighs (Int64 agent)\n\tD (Float64 model)\n\tdist (Float64 model)\n\n\nUPDATE RULES\nagentSDE\n begin\n    dt__x = D\n    dt__y = D\nend\n\nagentRule\n begin\n    nNeighs__ = 0\n    @loopOverNeighbors it2 begin\n            d = CBMMetrics.euclidean(x, x[it2], y, y[it2])\n            if d < dist\n                nNeighs__ += 1\n            end\n        end\nend\n\nagentODE\n begin\n    dt__x = -x\n    dt__y = -y\nend","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Several things to notice:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"The function dt and the parameter decorator dt__. Similarly what we do with rules adding a double underscore, we mark differential terms with the function dt, this function defines that this parameter is described by a differential equation and a new parameter is added to define that this variable is the differential term.\nODE and SDE. We put the deterministic term un the rule agentODE and the stochatic term in the rule agentSDE. We may not have a deterministic term or no stochastic term, that is not a problem.\nUse of neighbors macros. To go over the neighbors of an agent, we use the @loopOverNeighbors macro that requires that you specify an iterator index. Inside neighbors macros, you need to make a difference to which parameters are from the agent and which are the neighbors agent. If you see the line where the euclidean distance is computed you will realise that we specify the parameters of the second agent by providing the corresponding index of the neighboring position to them.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Let's see another example.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Example Consider that we want to define a model with a diffusive medium along the x axis and static cells secreting to medium. For now we will limit to have a medium without agents. The equation of diffusion has the form:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"fracpartial p(xt)partial t = Dfracpartial^2 p(xt)partial x^2","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"This continuous equation has to be discretized to be able to be integrated. We can use the macros we provide in the code.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"For the boundary solutions we can implement Dirichlet conditions:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"p(x_maxt) = 0","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"and Newman (reflective):","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"partial_x p(xt)_x=x_min = 0","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"which in discrete form will correspond to (taking a backward discretization):","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"$","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"\\frac{p(x{min})-p(x{min}-\\Delta x)}{\\Delta x} = 0$","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"and isolating:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"$","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"p(x{min})=p(x{min}-\\Delta x)$","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"model = ABM(2,\n    model = Dict(\n        :D => Float64\n        ),\n    agent = Dict(\n        :secrete => Float64\n    ),\n    medium = Dict(\n        :p=> Float64  #Number of neighbors that the agent has\n        ),\n    agentRule = quote\n        p += secrete*dt/dx*dy #Add to the medium the secretion content of each neighbor at each time point\n    end,\n    mediumODE = quote\n        if @mediumInside() #Diffusion inside bourders\n            dt(p) = @∂2(1,p)      #Second order diffusive term along x axis\n        elseif @mediumBorder(1,-1) #Newman (reflective) boundaries on the xmin border\n            p = p[2,i2_]    #Reflective at x border, along all y points             \n        elseif @mediumBorder(1,1) #Dirichlet (absorvant) boundary on the xmax border\n            p = 0                   \n        end\n    end,\n    mediumAlg = DifferentialEquations.AutoTsit5(DifferentialEquations.Rosenbrock23())\n)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\txₘ (Float64 medium)\n\tsecrete (Float64 agent)\n\tD (Float64 model)\n\tp (Float64 medium)\n\n\nUPDATE RULES\nmediumODE\n if @mediumInside()\n    dt__p = @∂2(1, p)\nelseif @mediumBorder(1, -1)\n    p__ = p[2]\nelseif @mediumBorder(1, 1)\n    p__ = 0\nend\n\nagentRule\n p__ += ((secrete * dt) / dx) * dy","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"By now you can already identify all the things that are happening:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"In an agent rule we are adding to the medium whatever the agent is secreting.\nWe used some provided macros to help out the writing of the model.\nUpdated parameters adquire the underscore and dt__ decorators.","category":"page"},{"location":"Usage_Agent.html#Algorithm-arguments","page":"Defining an ABM model","title":"Algorithm arguments","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Once defined the rules, you can define specific algorithms for the computation of the model. The possible arguments are:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"platform argument to define the type of platform in which you want to evolve the model.\nagentAlg, modelAlg and mediumAlg to define the integrator that you want to use. You can use our own integrators provided in the submodule CBMIntegrators that may be faster in general but in complex cases with stiff operation or in which you need high precission, you can always use the integrators from DifferentialEquations.jl suite. \nagentSolveArgs, modelSolveArgs and mediumSolveArgs to define additional arguments required by the integrators to work. This arguments are the ones present when definind a problem in DifferentialEquations.jl. \nneighbors algorithm. This defines the way of computing neighbors. This step is one of the most cost expensive in ABMs and the correct selection of algorithm can really afect your computational efficientcy. We provide several possible algorithms in the submodule CBMNeighbors.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"You should have seen some of this arguments declared in the code above.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"WARNING  When developing this library, these arguments where declared in the 'Community' object. now that we have a first stable version, they were moved to this object to solve a World agent problem when creating Communities inside functions.","category":"page"},{"location":"Usage_Agent.html#Model-inheritance","page":"Defining an ABM model","title":"Model inheritance","text":"","category":"section"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"The above set of parameters and rules can be used to define all type of agent models. Once we have a developed a model, we can extend the model with additional rules and parameters. This allows to contruct the models in a modular maner.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"There are two keyword parameters in the structure ABM for doing that:","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"baseModelInit: Models whose rules apply before the rules of the present ABM model.\nbaseModelEnd: Models whose rules apply after the rules of the present ABM model.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"The models provided will be concatenated in order of declaration.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Example Let's make modular the random walker and boundary conditions of the example provided above in Rules.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"modelFreeze = ABM(1, #Dimensions of the model\n    model = Dict(\n        :freeze => Bool\n    ),\n    modelRule = quote #Set freeze to false\n        if t < 10.\n            freeze = true\n        else\n            freeze = false\n        end\n    end,\n)\n\nmodelCombined = ABM(1, #Dimensions of the model\n    agent = Dict(\n        :l => Float64\n    ),\n    model = Dict(\n        :σ2 => Float64,    #Spread of the gaussian\n        :pDivision => Float64, #Global variable to set the probability at which it will divide\n    ),\n    agentRule = quote\n        x += freeze*Normal(0,σ2) \n        if x__ > simBox[1,2]\n            @removeAgent()\n        elseif pDivision < Uniform(0,1)\n            @addAgent(l = sin(Uniform(0,3*π)))\n        end\n    end,\n\n    baseModelInit = [modelFreeze]\n)","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"PARAMETERS\n\tx (Float64 agent)\n\tl (Float64 agent)\n\tpDivision (Float64 model)\n\tσ2 (Float64 model)\n\tfreeze (Bool model)\n\n\nUPDATE RULES\nmodelRule\n if t < 10.0\n    freeze__ = true\nelse\n    freeze__ = false\nend\n\nagentRule\n begin\n    x__ += freeze * Normal(0, σ2)\n    if x__ > simBox[1, 2]\n        @removeAgent\n    elseif pDivision < Uniform(0, 1)\n        @addAgent l__ = sin(Uniform(0, 3π))\n    end\nend","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"As you can see the combined model is the same as the model that we declared with all the rules together.","category":"page"},{"location":"Usage_Agent.html","page":"Defining an ABM model","title":"Defining an ABM model","text":"Notice that note all models will be inheritable. For example, if we tried to inherit the model the other way around iwe will find that the parameter freeze should have been declared in without declaring what it is. ","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"using CellBasedModels","category":"page"},{"location":"Usage_Community.html#Creating-and-evolving-a-Community","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"The Community structure contains the realization of an agent model. This structure will store the parameters of the agent and will be prepared to be evolved by the update rules defined.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Let's use for reference the Ornstein–Uhlenbeck process.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"model = ABM(2,\n    model = Dict(\n        :σ => Float64, #Diffussion constant\n        :theta => Float64  #Drifft force\n    ),\n    agentODE = quote\n        dt(x) = -theta*x\n        dt(y) = -theta*y\n    end,\n    agentSDE = quote\n        dt(x) = σ\n        dt(y) = σ\n    end,\n    agentAlg = DifferentialEquations.EM(), #Let's use an algorithm from DifferentialEquations suite\n)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"PARAMETERS\n\tx (Float64 agent)\n\ty (Float64 agent)\n\tσ (Float64 model)\n\ttheta (Float64 model)\n\n\nUPDATE RULES\nagentSDE\n begin\n\n\n\n\n\n\n    dt__x = σ\n    dt__y = σ\nend\n\nagentODE\n begin\n    dt__x = -theta * x\n    dt__y = -theta * y\nend","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"To create an initial community we just need to call a Community structure with an ABM model. ","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com = Community(model,\n                dt=0.1,\n                )","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Community with 1 agents.","category":"page"},{"location":"Usage_Community.html#KwArgs-of-the-Community-constructor","page":"Creating and evolving a Community","title":"KwArgs of the Community constructor","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"In addition to the model structure, we can provide the Community structure with keyword arguments. You can see all pf them in the API - Community documentation. Among them you will find:","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Base parameters like the time dt or the simulation box simBox.\nUser parameters.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"For example, we can define a community with more agents N, a simulationBox and random positions (x,y) in the unit box by constructing the Community as","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"N = 10\ncom = Community(model,\n        N=N,\n        simBox=[0 1;0 1.],\n        dt = 0.1,\n        x=Vector(1.:N),\n        y=rand(N)\n    )","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Community with 10 agents.","category":"page"},{"location":"Usage_Community.html#Accessing-and-manipulating-a-Community","page":"Creating and evolving a Community","title":"Accessing and manipulating a Community","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"You can access a community in two ways:","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Property: com.parameter\nIndex: com[:parameter]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"println(com.x)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"println(com[:x])","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"You can manipulate certain parameters in a community and assigning new values using the = operator.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"It works both for assigning a new array.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com.x = Vector(2:11.)\nprintln(com.x)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"[2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"and broad casting:","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com.x = 10\nprintln(com.x)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"[10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"NOTE Protected parameters You will not be able and modify later some of the parameters of the model such as N. This behavior is intended to not break the functionality of the program. For example:com.N = 10Parameter of community N is protected. If you really need to change it declare a new Community or use setfield! method (can be unstable).\n\nStacktrace:\n [1] setproperty!(com::Community, var::Symbol, v::Int64)\n   @ CellBasedModels ~/Documents/CellBasedModels.jl/src/CommunityStructure/communityStructure.jl:370\n [2] top-level scope\n   @ ~/Documents/CellBasedModels.jl/examples/Usage_Community.ipynb:1If you really need to change you can always use the function setfield! at your own risk of breacking the code.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"WARNING Avoid broadcasting As you can see the assign operator has been defined in such a way that works both for assigning new arrays to the parameters and broadcasting. I do not advice to use the broadcasted operator .= as it may change the behavior of protedted parameters which may modify in unexpected ways the results of the simulations,","category":"page"},{"location":"Usage_Community.html#IO","page":"Creating and evolving a Community","title":"IO","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"When evolving the system, you will want to save instances of the community. Currently there are two ways of saving them:","category":"page"},{"location":"Usage_Community.html#RAM","page":"Creating and evolving a Community","title":"RAM","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"For saving a function in RAM we can invoke the function saveRam!. This will save an instance of the current state in Community.pastTimes.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com.x = 10\nsaveRAM!(com)\ncom.x = 0.5\nprintln(\"Current state of x: \", com.x)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Current state of x: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"You can check how many instances have been saved using the function length on the community.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"length(com)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"1","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"And you can access any past community instance calling by index of the position.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"println(\"Past community x: \", com[1].x)\nprintln(\"Current community x: \", com.x)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Past community x: [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]\nCurrent community x: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]","category":"page"},{"location":"Usage_Community.html#JLD2","page":"Creating and evolving a Community","title":"JLD2","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"We can also save the instances in JLD2 format, a format based in H5MD saving files system that is compatible and readable from many other programming languages and platforms.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"saveJLD2(\"test.jld2\",com)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"And you can always call back the model from a JLD2 file.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com  = loadJLD2(\"test.jld2\")\ncom.loaded","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"false","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"This file will have all Community instances from the file loaded in Community.pastTimes and a copy of the last saved time in the current community itself.","category":"page"},{"location":"Usage_Community.html#Evolving-the-community","page":"Creating and evolving a Community","title":"Evolving the community","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Once we have defined a model and constructed an initial community, we can evolve it by the rules of the model.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"In the following schema we describe the basic collection of functions provided by the package to evolve the model, where some functions perform automatically all the step that are described on the right.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"<table>     <thead>         <th colspan=3> Functions </th>         <th> Description </th>     </thead>     <tbody>         <tr>             <td rowspan=12>evolve!</td>             <td colspan=2>loadToPlatform!</td>             <td>Function that loads the community information to the appropiate platform (CPU or GPU) for being able to evolve it. In CPU in fact nothing happens.</td>         </tr>         <tr>             <td rowspan=9>step!</td>         </tr>         <tr>             <td>agentStepDE!</td>             <td>Performs the agent DE step.</td>         </tr>         <tr>             <td>agentStepRule!</td>             <td>Performs the agent rule step.</td>         </tr>         <tr>             <td>mediumStepDE!</td>             <td>Performs the medium DE step.</td>         </tr>         <tr>             <td>mediumStepRule!</td>             <td>Performs the medium rule step.</td>         </tr>         <tr>             <td>modelStepDE!</td>             <td>Performs the model DE step.</td>         </tr>         <tr>             <td>modelStepRule!</td>             <td>Performs the model rule step.</td>         </tr>         <tr>             <td>update!</td>             <td>Saves all the updated parameters of the community as the present time. Until this function is called all the steps are stored as the future time and the step has not taken place yet!</td>         </tr>         <tr>             <td>computeNeighbors!</td>             <td>Uptdates de neighborhoods of the agents if necessary.</td>         </tr>         <tr>             <td colspan=2>saveRAM!/saveJLD2!</td>             <td>Save the current instance of the community.</td>         </tr>         <tr>             <td colspan=2>bringFromPlatform!</td>             <td>Brings back the community to RAM again.</td>         </tr>     </tbody> </table>","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Depending on the control that the user wants to have on the call of the evolution functions, they can decide to use one of the three column schemas proposed above.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"So simple evolutions in which we want only to evolve the model after initialization for certain time and save steps at fixed time points, the package already includes the function evolve!.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"evolve!(com,steps=100,saveEach=10)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"And we can see that our model has now ten more saved points.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"length(com)","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"10","category":"page"},{"location":"Usage_Community.html#Customizing-your-evolution-function","page":"Creating and evolving a Community","title":"Customizing your evolution function","text":"","category":"section"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"If you want a more fancy stepping function, you can use more atomic functions to have more control of the stepping process.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"Example Imagine that we want to save an instance only after some agent x has surpassed a a certain limit.","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"function evolveCustom!(com,steps)\n    loadToPlatform!(com) #Always necessary to load the parameters to the platform\n    for i in 1:steps\n        agentStepDE!(com) #This model only has an SDE that is updated with this function. \n        update!(com) #Always necessary to update the parameters at the end of all the steps.\n        if any(com.x .> 5.0)\n            saveRAM!(com)\n        end\n    end\n    bringFromPlatform!(com) #Always necessary to bring the data back to RAM after evolution lo unlock the agent.\nend;","category":"page"},{"location":"Usage_Community.html","page":"Creating and evolving a Community","title":"Creating and evolving a Community","text":"com = com[1] #Get initial instance of the agent above defined\n\nevolveCustom!(com,10)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The CellBasedModels.jl package aims to help fast-designing and simulation of agent-based models whith possibilities to be run in CPU and NVidia GPUs for the efficient computation of large-scale systems. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The following methods can be implemented in the model:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ODEs\nSDEs\nDivision\nDeath\nCoupling to continuum models evolving with PDEs\nRandom events","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Check the  Examples to get an idea of the capabilities of the package.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hopefully, soon we will make an official release in the Julia repository. For now, you can install the package from Github as:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/dsb-lab/CellBasedModels.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"or from the Pkg REPL","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add https://github.com/dsb-lab/CellBasedModels.jl","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Patterning","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table>\n    <tbody>\n        <tr>\n            <td style=\"height:200px\">\n                Implementation of a patterning model as described by <a href=\"https://www.science.org/doi/full/10.1126/science.aai7407?casa_token=_HGoX7kcWZcAAAAA%3AzoEGS_8EyLf7hNo9MC274EuqPACq6y4MsfCr93S9tzmmcK3pSTmNpJ7a7sc8HQMw5PETz7n9tG15jQ\">Corson et al. (2017)</a>.\n\n                In this example you learn how to:\n                <ul>\n                    <li>Write a full model from scratcht.</li>\n                    <li>Using external functions in your model.</li>\n                    <li>Deal with periodic boundary conditions.</li>\n                </ul>\n            </td>\n            <td>\n                <img src=\"./assets/patterning.gif\" width=\"800\" height=\"800\">\n            </td>\n        </tr>\n    </tbody>\n</table>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ICM Development","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table>\n    <tbody>\n        <tr style=\"height:200px\">\n            <td>\n                Implementation of the development and commitment of the Inner Cell Mass of the embryo as proposed by <a href=\"https://elifesciences.org/articles/56079\">Saiz et al. (2020)</a>.\n\n                In this example you learn how to:\n                <ul>\n                    <li>Use predefined models as base for more complex models.</li>\n                    <li>Extract data from the Community object.</li>\n                    <li>Making division events.</li>\n                    <li>Fit agent based models to data using the Fitting module.</li>\n                </ul>\n            </td>\n            <td>\n                <img src=\"./assets/Development.gif\" width=\"1200\" height=\"1200\">\n            </td>\n        </tr>\n    </tbody>\n</table>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Particle Aggregation","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table>\n    <tr>\n    <tbody>\n        <tr>\n            <td style=\"height:200px\">\n                Implementation of brownian particles with addesion properties and chack the aggregation transition.\n\n                In this example you learn how to:\n                <ul>\n                    <li>Write a full model from scratch and extend it.</li>\n                    <li>Modifying global parameters.</li>\n                    <li>Define boundary conditions.</li>\n                </ul>\n            </td>\n            <td>\n                <img src=\"./assets/aggregation.gif\" width=\"1000\" height=\"1000\">\n            </td>\n        </tr>\n    </tbody>\n</table>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Bacterial Colony Growth","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table>\n    <tbody>\n        <tr>\n            <td style=\"height:200px\">\n                Implementation of a bacterial interaction and growth model as described by <a href=\"https://www.pnas.org/doi/abs/10.1073/pnas.0706805105\">Volfson et al. (2008)</a>.\n\n                In this example you learn how to:\n                <ul>\n                    <li>Use predefined models as base for more complex models</li>\n                    <li>Working with non-spherical agents.</li>\n                    <li>Making division events.</li>\n                </ul>\n            </td>\n            <td>\n                <img src=\"./assets/colony.gif\" width=\"1000\" height=\"1000\">\n            </td>\n        </tr>\n    </tbody>\n</table>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Bacterial Chemotaxis","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table>\n    <tbody>\n        <tr>\n            <td style=\"height:200px\">\n                Modification of the bacterial interaction model as described by <a href=\"https://www.pnas.org/doi/abs/10.1073/pnas.0706805105\">Volfson et al. (2008)</a> to be active bacteria with tumble-and-run dynamics and chemotaxis behavior.\n\n                In this example you learn how to:\n                <ul>\n                    <li>Use predefined models as base for more complex models</li>\n                    <li>Working with non-spherical agents.</li>\n                    <li>Work with models coupled with a medium.</li>\n                </ul>\n            </td>\n            <td>\n                <img src=\"./assets/chemotaxis.gif\" width=\"1400\" height=\"1400\">\n            </td>\n        </tr>\n    </tbody>\n</table>","category":"page"},{"location":"index.html#Current-Limitations","page":"Home","title":"Current Limitations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"At the present stage of development, the library is not capable of working on batches of data. That means that the size of the simulated models will be limited by the memory disponibility in RAM or the GPU, depending on the platform in which the simulations are being tested. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Moreover, we can only use GPUs from NVidia as the GPU implementation is based on CUDA.jl.","category":"page"},{"location":"index.html#Future-work","page":"Home","title":"Future work","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We intend to extend the current version of the package with additional capabilities. Any help is welcome!","category":"page"},{"location":"index.html#Short-term","page":"Home","title":"Short term","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Addition of coupling to continuum systems.\nAdditions of inactive agents to make arbitrary shape boundaries.\nAdd more examples\nIncrease the number of implemented models.","category":"page"},{"location":"index.html#Long-term-goals","page":"Home","title":"Long term goals","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Extend GPU capabilities to be used also in other packages.\nMake optimization methods distributable among different CPU/GPUs.\n","category":"page"},{"location":"index.html#Alternatives-to-CellBasedModels.jl","page":"Home","title":"Alternatives to CellBasedModels.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Many different packages and programs have been developed for constructing agent-based models. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Non-Julia-based specific software:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"NetLogo is mostly focused on discrete dynamics. It is a bit outdated.\nMason Developed in Java, it is discrete-step-based software.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Non-Julia-based generic software:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ya||a Software developed with CUDA/C++. It is fast as it is fully parallelized but apart from already written models, that are specific for the study of limb morphogenesis, advanced knowledge of CUDA and C++ is required for any customization. \nMesa is developed in Python with a very intuitive framework. It is specialized in discrete dynamics in grid spaces.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Julia-based generic software:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Agents.jl. To our knowledge, there is only one alternative package written in Julia for the construction and deployment of agent-based models. It is a mature library and is the way to go for agent-based models in Julia for discrete-time dynamics. As another agent-based library, our library and the Agent.jl library overlaps in some of the capabilities and both can construct models in continuous space with similar capabilities. We focus our library on the simulation of continuous spaces with a continuous time that is described in terms of differential equations with the added value of being able to escalate the system to large amounts of agents by simulating in CUDA. ","category":"page"}]
}
